import osimport jsonimport uuidimport timeimport randomimport smtplibimport hashlibimport loggingimport requestsfrom email.mime.text import MIMETextfrom tablestore import OTSClient, Row, Condition, RowExistenceExpectation, INF_MIN, INF_MAX, SingleColumnCondition, \    ComparatorType, CompositeColumnCondition, LogicalOperatorfrom tablestore.error import OTSServiceErrorfrom tablestore.metadata import TableMeta, TableOptions, ReservedThroughput, CapacityUnitimport oss2from flask import Flask, request, jsonifyfrom functools import wraps# 配置日志logging.basicConfig(level=logging.INFO)logger = logging.getLogger()# 获取环境变量def get_env(key, default=None):    value = os.getenv(key, default)    if value is None:        logger.error(f"环境变量 {key} 未设置!")    return value# 读取环境变量OTS_INSTANCE_NAME = get_env('OTS_INSTANCE_NAME', 'book-mgmt-ots')OTS_ENDPOINT = get_env('OTS_ENDPOINT', 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')OTS_TABLE_NAME = get_env('OTS_TABLE_NAME', 'Books')USERS_TABLE = get_env('USERS_TABLE', 'Users')VERIFICATION_CODES_TABLE = get_env('VERIFICATION_CODES_TABLE', 'VerificationCodes')BORROW_RECORDS_TABLE = get_env('BORROW_RECORDS_TABLE', 'BorrowRecords')FAVORITES_TABLE = get_env('FAVORITES_TABLE', 'Favorites')VIEW_HISTORY_TABLE = get_env('VIEW_HISTORY_TABLE', 'ViewHistory')ANNOUNCEMENTS_TABLE = get_env('ANNOUNCEMENTS_TABLE', 'Announcements')OSS_BUCKET_NAME = get_env('OSS_BUCKET_NAME', 'book-mgmt-images')OSS_ENDPOINT = get_env('OSS_ENDPOINT', 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx').strip()ALIYUN_ACCESS_KEY = get_env('ALIYUN_ACCESS_KEY', 'xxxxxxxxxxxxxxxxxxxxxxxxxxxx')ALIYUN_ACCESS_SECRET = get_env('ALIYUN_ACCESS_SECRET', 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')ALIYUN_REGION = get_env('ALIYUN_REGION', 'cn-hangzhou')EMAIL_HOST = get_env('EMAIL_HOST', 'smtp.qq.com')EMAIL_PORT = int(get_env('EMAIL_PORT', '465'))EMAIL_USER = get_env('EMAIL_USER', 'xxxxxxxxxxxxxxxxxxxxxxxxxxx')EMAIL_PASSWORD = get_env('EMAIL_PASSWORD', 'xxxxxxxxxxxxxxxxxxxxxxxxxxxx')DEEPSEEK_API_KEY = get_env('DEEPSEEK_API_KEY', 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')ADMIN_CODE = get_env('ADMIN_CODE', 'xxxxxxxxxxxxxxxxxxxxxxxxxx')  # 管理员码COMMENTS_TABLE = get_env('COMMENTS_TABLE', 'Comments')RESERVATIONS_TABLE = get_env('RESERVATIONS_TABLE', 'Reservations')# 检查必要的访问密钥if not ALIYUN_ACCESS_KEY or not ALIYUN_ACCESS_SECRET:    logger.error("阿里云访问密钥未设置！请配置ALIYUN_ACCESS_KEY和ALIYUN_ACCESS_SECRET环境变量")    exit(1)# 初始化客户端try:    logger.info(f"初始化OTS客户端: 端点={OTS_ENDPOINT}, 实例={OTS_INSTANCE_NAME}")    ots_client = OTSClient(        OTS_ENDPOINT,        ALIYUN_ACCESS_KEY,        ALIYUN_ACCESS_SECRET,        OTS_INSTANCE_NAME,        logger_name='ots',        log_level=logging.INFO    )    logger.info(f"初始化OSS客户端: 存储桶={OSS_BUCKET_NAME}, 端点={OSS_ENDPOINT}")    oss_auth = oss2.Auth(ALIYUN_ACCESS_KEY, ALIYUN_ACCESS_SECRET)    oss_bucket = oss2.Bucket(oss_auth, OSS_ENDPOINT, OSS_BUCKET_NAME)    logger.info("OTS和OSS客户端初始化成功")except Exception as e:    logger.error(f"客户端初始化失败: {str(e)}", exc_info=True)    exit(1)# 创建Flask应用app = Flask(__name__)# 全局CORS处理@app.after_requestdef add_cors_headers(response):    response.headers['Access-Control-Allow-Origin'] = '*'    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'    return response# 创建必要的表格def create_tables():    try:        # 定义表格选项和预留吞吐量（移到函数顶部）        table_options = TableOptions()        reserved_throughput = ReservedThroughput(CapacityUnit(0, 0))        # 创建图书表        if OTS_TABLE_NAME not in ots_client.list_table():            logger.info("创建图书表...")            table_meta = TableMeta(OTS_TABLE_NAME, [('book_id', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"图书表 {OTS_TABLE_NAME} 创建成功")        # 创建用户表        if USERS_TABLE not in ots_client.list_table():            logger.info("创建用户表...")            table_meta = TableMeta(USERS_TABLE, [('email', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"用户表 {USERS_TABLE} 创建成功")        # 创建验证码表        if VERIFICATION_CODES_TABLE not in ots_client.list_table():            logger.info("创建验证码表...")            table_meta = TableMeta(VERIFICATION_CODES_TABLE, [('email', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"验证码表 {VERIFICATION_CODES_TABLE} 创建成功")        # 创建借阅记录表        if BORROW_RECORDS_TABLE not in ots_client.list_table():            logger.info("创建借阅记录表...")            table_meta = TableMeta(BORROW_RECORDS_TABLE, [('borrow_id', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"借阅记录表 {BORROW_RECORDS_TABLE} 创建成功")        # 创建收藏表        if FAVORITES_TABLE not in ots_client.list_table():            logger.info("创建收藏表...")            table_meta = TableMeta(FAVORITES_TABLE, [('favorite_id', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"收藏表 {FAVORITES_TABLE} 创建成功")        # 创建浏览历史表        if VIEW_HISTORY_TABLE not in ots_client.list_table():            logger.info("创建浏览历史表...")            table_meta = TableMeta(VIEW_HISTORY_TABLE, [('history_id', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"浏览历史表 {VIEW_HISTORY_TABLE} 创建成功")        # 创建公告表        if ANNOUNCEMENTS_TABLE not in ots_client.list_table():            logger.info("创建公告表...")            table_meta = TableMeta(ANNOUNCEMENTS_TABLE, [('announcement_id', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"公告表 {ANNOUNCEMENTS_TABLE} 创建成功")        if COMMENTS_TABLE not in ots_client.list_table():            logger.info("创建评论表...")            table_meta = TableMeta(COMMENTS_TABLE, [('comment_id', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"评论表 {COMMENTS_TABLE} 创建成功")        if RESERVATIONS_TABLE not in ots_client.list_table():            logger.info("创建预约记录表...")            table_meta = TableMeta(RESERVATIONS_TABLE, [('reservation_id', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"预约记录表 {RESERVATIONS_TABLE} 创建成功")    except Exception as e:        logger.error(f"创建表格失败: {str(e)}", exc_info=True)# 初始化时创建表格create_tables()# 密码哈希函数def hash_password(password):    return hashlib.sha256(password.encode('utf-8')).hexdigest()# 发送验证码def send_verification_code(email):    code = str(random.randint(100000, 999999))    logger.info(f"为 {email} 生成验证码: {code}")    expire_time = int(time.time()) + 300    current_time = int(time.time())    try:        primary_key = [('email', email)]        attribute_columns = [            ('code', code),            ('expire_time', expire_time),            ('created_at', current_time),  # 新增            ('updated_at', current_time)  # 新增        ]        row = Row(primary_key, attribute_columns)        ots_client.put_row(VERIFICATION_CODES_TABLE, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"验证码存储成功: {email}")    except Exception as e:        logger.error(f"存储验证码失败: {str(e)}", exc_info=True)        return False    try:        message = MIMEText(f"欢迎来到FluxLib泛集库，您的验证码是: {code}，5分钟内有效。")        message['Subject'] = 'FluxLib泛集库注册验证码'        message['From'] = EMAIL_USER        message['To'] = email        with smtplib.SMTP_SSL(EMAIL_HOST, EMAIL_PORT) as server:            server.login(EMAIL_USER, EMAIL_PASSWORD)            server.sendmail(EMAIL_USER, [email], message.as_string())            logger.info(f"验证码邮件发送成功: {email}")        return True    except Exception as e:        logger.error(f"发送邮件失败: {str(e)}", exc_info=True)        return False# 验证验证码def verify_code(email, code):    try:        primary_key = [('email', email)]        consumed, return_row, next_token = ots_client.get_row(            VERIFICATION_CODES_TABLE,            primary_key,            columns_to_get=['code', 'expire_time']        )        if return_row is None:            logger.warning(f"验证码记录不存在: {email}")            return False        stored_code = None        expire_time = 0        for col_name, col_value, col_timestamp in return_row.attribute_columns:            if col_name == 'code':                stored_code = col_value            elif col_name == 'expire_time':                expire_time = col_value        current_time = int(time.time())        if stored_code == code and expire_time > current_time:            logger.info(f"验证码验证成功: {email}")            return True        logger.warning(f"验证码无效或已过期: {email}")        return False    except Exception as e:        logger.error(f"验证验证码失败: {str(e)}", exc_info=True)        return False# 获取用户信息def get_user(email):    try:        primary_key = [('email', email)]        consumed, return_row, next_token = ots_client.get_row(USERS_TABLE, primary_key)        if return_row is None:            logger.info(f"用户不存在: {email}")            return None        user = {'email': email}        for col_name, col_value, col_timestamp in return_row.attribute_columns:            user[col_name] = col_value        logger.info(f"获取用户成功: {email}")        return user    except Exception as e:        logger.error(f"获取用户失败: {str(e)}", exc_info=True)        return None# 注册用户def register_user(email, password, code, gender=None):    if not verify_code(email, code):        return False, "验证码错误或已过期"    if get_user(email):        return False, "该邮箱已注册"    user_id = str(uuid.uuid4())    hashed_pw = hash_password(password)    created_at = int(time.time())    display_name = email.split('@')[0]  # 默认使用邮箱前缀作为显示名    avatar_url = f"https://api.dicebear.com/7.x/initials/svg?seed={display_name}"  # 默认头像    try:        primary_key = [('email', email)]        attribute_columns = [            ('user_id', user_id),            ('password', hashed_pw),            ('created_at', created_at),            ('updated_at', created_at),  # 新增：初始与created_at一致            ('role', 'user'),            ('is_verified', 'true'),            ('display_name', display_name),            ('avatar_url', avatar_url),            ('gender', gender or '')        ]        row = Row(primary_key, attribute_columns)        # 使用原始条件字符串        ots_client.put_row(USERS_TABLE, row, Condition(RowExistenceExpectation.EXPECT_NOT_EXIST))        logger.info(f"用户注册成功: {email}")        return True, user_id    except Exception as e:        logger.error(f"注册用户失败: {str(e)}", exc_info=True)        return False, str(e)# 用户登录 - 修改为临时管理员权限def login_user(email, password, admin_code=None):    logger.info(f"登录请求: email={email}, admin_code={admin_code}")    user = get_user(email)    if not user:        logger.warning(f"用户不存在: {email}")        return False, "用户不存在"    hashed_pw = hash_password(password)    if user['password'] != hashed_pw:        logger.warning(f"密码错误: {email}")        return False, "密码错误"    # 检查管理员码    is_temporary_admin = False    if admin_code:        logger.info(f"验证管理员码: 输入={admin_code}, 正确={ADMIN_CODE}")        if admin_code != ADMIN_CODE:            logger.warning(f"管理员码错误: 输入={admin_code}, 正确={ADMIN_CODE}")            return False, "管理员码错误"        else:            # 管理员码正确，但不在数据库中更新角色，只在本次登录中标记为临时管理员            is_temporary_admin = True            logger.info(f"用户 {email} 使用管理员码登录，获得临时管理员权限")    # 注意：不再更新数据库中的角色，保持用户原有角色    logger.info(f"用户登录成功: {email}, 临时管理员: {is_temporary_admin}")    return True, {        'user_id': user['user_id'],        'email': email,        'role': 'admin' if is_temporary_admin else user.get('role', 'user'),  # 如果使用了管理员码，则返回admin，否则返回数据库中的角色        'is_admin': is_temporary_admin,  # 新增字段，表示本次登录是否为临时管理员        'is_temporary_admin': is_temporary_admin  # 明确标识这是临时管理员    }# 创建管理员账户def create_admin_user():    admin_email = "admin@bookmgmt.com"    admin_password = "Admin@1234"    if not get_user(admin_email):        user_id = str(uuid.uuid4())        hashed_pw = hash_password(admin_password)        created_at = int(time.time())        try:            primary_key = [('email', admin_email)]            attribute_columns = [                ('user_id', user_id),                ('password', hashed_pw),                ('created_at', created_at),                ('role', 'admin'),                ('is_verified', 'true')            ]            row = Row(primary_key, attribute_columns)            # 使用原始条件字符串            ots_client.put_row(USERS_TABLE, row, Condition(RowExistenceExpectation.IGNORE))            logger.info(f"管理员账户已创建: {admin_email}")        except Exception as e:            logger.error(f"创建管理员失败: {str(e)}", exc_info=True)# 获取图书总数def get_total_books(category=None):    try:        count = 0        start_primary_key = [('book_id', INF_MIN)]        end_primary_key = [('book_id', INF_MAX)]        condition = None        if category:            condition = SingleColumnCondition(                'category',                category,                ComparatorType.EQUAL            )        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                OTS_TABLE_NAME,                'FORWARD',                next_start_primary_key,                end_primary_key,                limit=1000,                max_version=1,                column_filter=condition            )            count += len(row_list)        return count    except Exception as e:        logger.error(f"获取图书总数失败: {str(e)}", exc_info=True)        return 0# 获取图书列表def get_books(page=1, size=10):    try:        category = request.args.get('category', '')        offset = (page - 1) * size        start_primary_key = [('book_id', INF_MIN)]        end_primary_key = [('book_id', INF_MAX)]        condition = None        if category:            condition = SingleColumnCondition(                'category',                category,                ComparatorType.EQUAL            )        consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(            OTS_TABLE_NAME,            'FORWARD',            start_primary_key,            end_primary_key,            limit=size,            max_version=1,            column_filter=condition        )        books = []        for row in row_list:            book = {}            for pk in row.primary_key:                book[pk[0]] = pk[1]            for col in row.attribute_columns:                book[col[0]] = col[1]            # 确保所有字段存在            books.append({                'book_id': book.get('book_id', ''),                'title': book.get('title', ''),                'cover': book.get('cover', ''),                'category': book.get('category', ''),                'status': book.get('status', 'available'),                'stock': int(book.get('stock', 0)),                'author': book.get('author', ''),                'publisher': book.get('publisher', ''),                'price': float(book.get('price', 0.0)),                'summary': book.get('summary', ''),  # 添加图书概述                'description': book.get('description', '')  # 确保描述字段也存在            })        total = get_total_books(category)        # 确保返回正确的数据结构        return {            'statusCode': 200,            'headers': {'Content-Type': 'application/json'},            'body': json.dumps({                'items': books,                'total': total,                'page': page,                'size': size            })        }    except Exception as e:        logger.error(f"获取图书列表失败: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'headers': {'Content-Type': 'application/json'},            'body': json.dumps({'error': 'Failed to get books'})        }# 创建图书def create_book(book_data):    try:        if not book_data.get('title'):            return {                'statusCode': 400,                'body': json.dumps({'error': '书名是必填项'})            }        book = {            'book_id': str(uuid.uuid4()),            'created_at': int(time.time()),            'updated_at': int(time.time()),            'status': book_data.get('status', 'available'),            'stock': int(book_data.get('stock', 0))        }        fields = ['title', 'author', 'publisher', 'isbn', 'price', 'category', 'description', 'cover', 'summary']        for field in fields:            if field in book_data:                book[field] = book_data[field]        if 'price' in book:            try:                book['price'] = float(book['price'])            except:                book['price'] = 0.0        primary_key = [('book_id', book['book_id'])]        attribute_columns = []        for key, value in book.items():            if key != 'book_id':                attribute_columns.append((key, value))        row = Row(primary_key, attribute_columns)        # 使用原始条件字符串        ots_client.put_row(OTS_TABLE_NAME, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"创建图书成功: {book['book_id']}")        return {            'statusCode': 201,            'headers': {'Content-Type': 'application/json'},            'body': json.dumps({                'book_id': book['book_id'],                'message': '图书创建成功'            })        }    except Exception as e:        logger.error(f"创建图书失败: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'headers': {'Content-Type': 'application/json'},            'body': json.dumps({                'error': '创建图书失败',                'detail': str(e)            })        }# 获取图书详情def get_book(book_id):    try:        primary_key = [('book_id', book_id)]        consumed, return_row, next_token = ots_client.get_row(OTS_TABLE_NAME, primary_key)        if return_row is None:            return {                'statusCode': 404,                'body': json.dumps({'error': 'Book not found'})            }        book = {}        for pk in return_row.primary_key:            book[pk[0]] = pk[1]        for col in return_row.attribute_columns:            book[col[0]] = col[1]        # 确保数字字段类型正确        book['stock'] = int(book.get('stock', 0))        book['price'] = float(book.get('price', 0.0))        # 获取借阅历史        book['borrow_history'] = get_borrow_history(book_id)        return {            'statusCode': 200,            'body': json.dumps(book)        }    except Exception as e:        logger.error(f"获取图书失败: {book_id} - {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': 'Failed to get book'})        }# 获取借阅历史def get_borrow_history(book_id):    try:        # 直接使用全表扫描，不使用条件过滤        history = []        start_primary_key = [('borrow_id', INF_MIN)]        end_primary_key = [('borrow_id', INF_MAX)]        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                BORROW_RECORDS_TABLE,                'FORWARD',                next_start_primary_key,                end_primary_key,                limit=100,                max_version=1            )            for row in row_list:                record = {}                for pk in row.primary_key:                    record[pk[0]] = pk[1]                for col in row.attribute_columns:                    record[col[0]] = col[1]                # 在内存中过滤                if record.get('book_id') == book_id:                    # 确保日期字段为整数                    if 'borrow_date' in record:                        record['borrow_date'] = int(record['borrow_date'])                    if 'due_date' in record:                        record['due_date'] = int(record['due_date'])                    history.append(record)        return history    except Exception as e:        logger.error(f"获取借阅历史失败: {book_id} - {str(e)}", exc_info=True)        return []# 更新图书def update_book(book_id, book_data):    try:        if not book_data:            return {                'statusCode': 400,                'body': json.dumps({'error': 'Invalid request body'})            }        book_data['updated_at'] = int(time.time())        primary_key = [('book_id', book_id)]        update_of_attribute_columns = {'PUT': []}        for key, value in book_data.items():            if key != 'book_id':                update_of_attribute_columns['PUT'].append((key, value))        # 创建Row对象        row = Row(primary_key, update_of_attribute_columns)        # 使用原始条件字符串        ots_client.update_row(OTS_TABLE_NAME, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"更新图书成功: {book_id}")        return {            'statusCode': 200,            'body': json.dumps({'message': 'Book updated successfully'})        }    except Exception as e:        logger.error(f"更新图书失败: {book_id} - {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': 'Failed to update book'})        }# 删除图书def delete_book(book_id):    try:        # 确保 primary_key 是正确的格式        primary_key = [('book_id', book_id)]        # 创建 Row 对象，只包含主键信息        row = Row(primary_key)        # 使用正确的条件        condition = Condition(RowExistenceExpectation.IGNORE)        # 调用删除操作        ots_client.delete_row(OTS_TABLE_NAME, row, condition)        logger.info(f"删除图书成功: {book_id}")        return {            'statusCode': 200,            'body': json.dumps({'message': 'Book deleted successfully'})        }    except OTSServiceError as e:        logger.error(f"OTS服务错误: {e.message}, code={e.code}")        return {            'statusCode': 500,            'body': json.dumps({'error': '删除失败: OTS服务错误'})        }    except Exception as e:        logger.error(f"删除图书失败: {book_id} - {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '删除失败'})        }# 生成预签名URLdef generate_presigned_url(file_name, file_type):    try:        if not file_name or not file_type:            return {                'statusCode': 400,                'body': json.dumps({'error': 'Missing file_name or file_type'})            }        unique_name = f"{uuid.uuid4()}-{file_name}"        object_path = f"book-covers/{unique_name}"        headers = {'Content-Type': file_type}        url = oss_bucket.sign_url('PUT', object_path, 3600, headers=headers)        endpoint = OSS_ENDPOINT.replace('https://', '').replace('http://', '')        access_url = f"https://{OSS_BUCKET_NAME}.{endpoint}/{object_path}"        return {            'statusCode': 200,            'body': json.dumps({                'presigned_url': url,                'access_url': access_url            })        }    except Exception as e:        logger.error(f"生成预签名URL失败: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({                'error': '生成预签名URL失败',                'detail': str(e)            })        }# 获取当前用户ID - 添加详细日志def get_current_user_id(headers):    auth_header = headers.get('Authorization', '')    logger.info(f"Authorization header: '{auth_header}'")    if auth_header.startswith('Bearer '):        token = auth_header[7:]        logger.info(f"Extracted token: {token}")        user_id = get_user_id_by_token(token)        if user_id:            return user_id        else:            logger.warning("Invalid or expired token")            return None    logger.warning("Authorization header missing or invalid format")    return None# 获取用户的借阅记录def get_borrowing_record(book_id, user_id):    try:        # 查询借阅记录        start_primary_key = [('borrow_id', INF_MIN)]        end_primary_key = [('borrow_id', INF_MAX)]        # 创建复合条件：图书ID + 用户ID + 状态为borrowed        composite_condition = CompositeColumnCondition(LogicalOperator.AND)        composite_condition.add_sub_condition(            SingleColumnCondition('book_id', book_id, ComparatorType.EQUAL)        )        composite_condition.add_sub_condition(            SingleColumnCondition('user_id', user_id, ComparatorType.EQUAL)        )        composite_condition.add_sub_condition(            SingleColumnCondition('status', 'borrowed', ComparatorType.EQUAL)        )        consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(            BORROW_RECORDS_TABLE,            'FORWARD',            start_primary_key,  # 修改：使用start_primary_key而不是next_start_primary_key            end_primary_key,            max_version=1,            column_filter=composite_condition,            limit=1  # 只获取一条记录        )        if not row_list:            return None        # 提取借阅记录        record = {}        row = row_list[0]        for pk in row.primary_key:            record[pk[0]] = pk[1]        for col in row.attribute_columns:            record[col[0]] = col[1]        return record    except Exception as e:        logger.error(f"获取借阅记录失败: {str(e)}", exc_info=True)        return None# 预约借阅图书def reserve_book(book_id, headers, reserve_date, time_slot, days=30):    try:        logger.info(f"开始预约图书: book_id={book_id}, reserve_date={reserve_date}, time_slot={time_slot}, days={days}")        user_id = get_current_user_id(headers)        if not user_id:            logger.warning("未授权访问，无法获取用户ID")            return {                'statusCode': 401,                'body': json.dumps({'error': '未授权访问'})            }        # 获取图书信息检查库存        book_response = get_book(book_id)        if book_response['statusCode'] != 200:            return book_response        try:            book_info = json.loads(book_response['body'])        except Exception as e:            logger.error(f"解析图书信息失败: {str(e)}")            return {                'statusCode': 500,                'body': json.dumps({'error': '解析图书信息失败'})            }        # 确保库存字段存在且为整数        stock = book_info.get('stock', 0)        try:            stock = int(stock)        except:            stock = 0        logger.info(f"预约前库存检查: book_id={book_id}, stock={stock}")        if stock <= 0:            # 获取最早的归还日期            earliest_return_date = get_earliest_return_date(book_id)            logger.warning(f"库存不足，无法预约: book_id={book_id}, stock={stock}")            return {                'statusCode': 400,                'body': json.dumps({                    'error': '图书库存不足',                    'earliest_available_date': earliest_return_date,                    'message': f'抱歉，图书库存为0，您可以收藏此书，在{earliest_return_date}之后再来'                })            }        # 创建预约记录        reservation_id = str(uuid.uuid4())        reserve_data = {            'reservation_id': reservation_id,            'book_id': book_id,            'user_id': user_id,            'reserve_date': reserve_date,            'time_slot': time_slot,            'days': days,            'expected_return_date': calculate_return_date(reserve_date, days),            'status': 'reserved',            'created_at': int(time.time()),  # 原有            'updated_at': int(time.time())  # 新增        }        try:            reservation_primary_key = [('reservation_id', reservation_id)]            reservation_attribute_columns = []            for key, value in reserve_data.items():                if key != 'reservation_id':                    reservation_attribute_columns.append((key, value))            reservation_row = Row(reservation_primary_key, reservation_attribute_columns)            ots_client.put_row(RESERVATIONS_TABLE, reservation_row, Condition(RowExistenceExpectation.IGNORE))            logger.info(f"预约记录创建成功: reservation_id={reservation_id}")            # 发送通知给用户            user = get_user_by_id(user_id)            if user and user.get('email'):                send_reservation_confirmation(user['email'], book_info, reserve_data)            return {                'statusCode': 200,                'body': json.dumps({                    'success': True,                    'reservation_id': reservation_id,                    'expected_return_date': reserve_data['expected_return_date']                })            }        except Exception as e:            logger.error(f"创建预约记录失败: {str(e)}", exc_info=True)            return {                'statusCode': 500,                'body': json.dumps({'error': '预约失败'})            }    except Exception as e:        logger.error(f"预约图书失败 [book_id={book_id}, user_id={user_id}]: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '预约失败'})        }# 获取最早的归还日期def get_earliest_return_date(book_id):    try:        # 查询所有借阅记录，找到最早的归还日期        start_primary_key = [('borrow_id', INF_MIN)]        end_primary_key = [('borrow_id', INF_MAX)]        condition = CompositeColumnCondition(LogicalOperator.AND)        condition.add_sub_condition(SingleColumnCondition('book_id', book_id, ComparatorType.EQUAL))        condition.add_sub_condition(SingleColumnCondition('status', 'borrowed', ComparatorType.EQUAL))        earliest_date = None        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                BORROW_RECORDS_TABLE,                'FORWARD',                next_start_primary_key,                end_primary_key,                max_version=1,                column_filter=condition            )            for row in row_list:                record = {}                for pk in row.primary_key:                    record[pk[0]] = pk[1]                for col in row.attribute_columns:                    record[col[0]] = col[1]                return_date = record.get('due_date')                if return_date and (earliest_date is None or return_date < earliest_date):                    earliest_date = return_date        if earliest_date:            return time.strftime('%Y-%m-%d', time.localtime(earliest_date))        else:            return "未知日期"    except Exception as e:        logger.error(f"获取最早归还日期失败: {str(e)}", exc_info=True)        return "未知日期"# 计算归还日期def calculate_return_date(reserve_date, days):    try:        # 将预约日期转换为时间戳        reserve_timestamp = int(time.mktime(time.strptime(reserve_date, '%Y-%m-%d')))        # 计算归还日期        return_timestamp = reserve_timestamp + days * 24 * 3600        return return_timestamp    except Exception as e:        logger.error(f"计算归还日期失败: {str(e)}")        return int(time.time()) + days * 24 * 3600# 发送预约确认邮件def send_reservation_confirmation(email, book_info, reserve_data):    try:        message = MIMEText(f"""        您的图书预约已成功创建！        图书信息:        书名: {book_info.get('title', '未知')}        作者: {book_info.get('author', '未知')}        预约详情:        预约日期: {reserve_data['reserve_date']}        时间段: {reserve_data['time_slot']}        借阅天数: {reserve_data['days']}        预计归还日期: {time.strftime('%Y-%m-%d', time.localtime(reserve_data['expected_return_date']))}        请按时到图书馆借阅图书。        """)        message['Subject'] = 'FluxLib泛集库图书预约确认'        message['From'] = EMAIL_USER        message['To'] = email        with smtplib.SMTP_SSL(EMAIL_HOST, EMAIL_PORT) as server:            server.login(EMAIL_USER, EMAIL_PASSWORD)            server.sendmail(EMAIL_USER, [email], message.as_string())            logger.info(f"预约确认邮件发送成功: {email}")        return True    except Exception as e:        logger.error(f"发送预约确认邮件失败: {str(e)}", exc_info=True)        return False# 归还图书 - 支持提前归还def return_book(book_id, headers, is_early_return=False):    try:        user_id = get_current_user_id(headers)        if not user_id:            logger.warning("未授权访问，无法获取用户ID")            return {                'statusCode': 401,                'body': json.dumps({'error': '未授权访问'})            }        # 获取用户的借阅记录（状态为borrowed）        borrow_record = get_borrowing_record(book_id, user_id)        if not borrow_record:            logger.warning(f"未找到借阅记录: book_id={book_id}, user_id={user_id}")            return {                'statusCode': 400,                'body': json.dumps({'error': '未找到借阅记录'})            }        borrow_id = borrow_record.get('borrow_id')        if not borrow_id:            logger.warning("借阅记录中未找到borrow_id")            return {                'statusCode': 500,                'body': json.dumps({'error': '借阅记录格式错误'})            }        # 获取图书当前库存        book_response = get_book(book_id)        if book_response['statusCode'] != 200:            return book_response        try:            book_info = json.loads(book_response['body'])            stock = book_info.get('stock', 0)            try:                stock = int(stock)            except:                stock = 0        except:            stock = 0        # 增加库存        primary_key = [('book_id', book_id)]        update_of_attribute_columns = {            'PUT': [                ('stock', stock + 1),                ('updated_at', int(time.time()))            ]        }        # 创建Row对象        row = Row(primary_key, update_of_attribute_columns)        ots_client.update_row(            OTS_TABLE_NAME,            row,            Condition(RowExistenceExpectation.IGNORE)        )        logger.info(f"库存增加成功: book_id={book_id}, 新库存={stock + 1}")        # 更新借阅记录状态为已归还        borrow_primary_key = [('borrow_id', borrow_id)]        update_borrow_columns = {            'PUT': [                ('status', 'returned'),                ('return_date', int(time.time())),                ('is_early_return', is_early_return),                ('updated_at', int(time.time()))  # 新增：同步更新最后修改时间            ]        }        # 创建Row对象        row = Row(borrow_primary_key, update_borrow_columns)        ots_client.update_row(            BORROW_RECORDS_TABLE,            row,            Condition(RowExistenceExpectation.IGNORE)        )        logger.info(f"借阅记录更新为已归还: borrow_id={borrow_id}, 提前归还: {is_early_return}")        return {            'statusCode': 200,            'body': json.dumps({                'success': True,                'is_early_return': is_early_return,                'message': '归还成功' + ('（提前归还）' if is_early_return else '')            })        }    except Exception as e:        logger.error(f"归还图书失败 [book_id={book_id}, user_id={user_id}]: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '归还失败'})        }def get_user_id_by_token(token):    try:        # 由于用户表的主键是 email，我们需要通过扫描来找到匹配的用户        # 创建一个条件：user_id 等于 token        condition = SingleColumnCondition(            'user_id',            token,            ComparatorType.EQUAL        )        # 扫描用户表        start_primary_key = [('email', INF_MIN)]        end_primary_key = [('email', INF_MAX)]        consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(            USERS_TABLE,            'FORWARD',            start_primary_key,            end_primary_key,            max_version=1,            column_filter=condition,            limit=1  # 只获取一条记录        )        if row_list and len(row_list) > 0:            # 提取用户信息            user = {}            for pk in row_list[0].primary_key:                user[pk[0]] = pk[1]            for col in row_list[0].attribute_columns:                user[col[0]] = col[1]            logger.info(f"通过token找到用户: {user.get('email')}")            return user.get('user_id')        else:            logger.warning(f"未找到匹配token的用户: {token}")            return None    except Exception as e:        logger.error(f"获取用户ID失败: {str(e)}", exc_info=True)        return None# 借阅图书 - 使用get_row + put_row代替update_rowdef borrow_book(book_id, headers, days=30):    try:        logger.info(f"开始借阅图书: book_id={book_id}, days={days}")        user_id = get_current_user_id(headers)        if not user_id:            logger.warning("未授权访问，无法获取用户ID")            return {                'statusCode': 401,                'body': json.dumps({'error': '未授权访问'})            }        logger.info(f"用户已授权: user_id={user_id}")        # 获取图书信息检查库存        book_response = get_book(book_id)        logger.info(f"获取图书详情响应: statusCode={book_response['statusCode']}")        # 检查图书详情响应状态        if book_response['statusCode'] != 200:            logger.warning(f"获取图书详情失败: statusCode={book_response['statusCode']}")            return book_response        try:            book_info = json.loads(book_response['body'])        except Exception as e:            logger.error(f"解析图书信息失败: {str(e)}")            return {                'statusCode': 500,                'body': json.dumps({'error': '解析图书信息失败'})            }        # 确保库存字段存在且为整数        stock = book_info.get('stock', 0)        try:            stock = int(stock)        except:            stock = 0        logger.info(f"借阅前库存检查: book_id={book_id}, stock={stock}")        if stock <= 0:            logger.warning(f"库存不足，无法借阅: book_id={book_id}, stock={stock}")            return {                'statusCode': 400,                'body': json.dumps({'error': '图书库存不足'})            }        # 使用get_row获取完整图书数据        try:            # 获取图书当前所有属性            primary_key = [('book_id', book_id)]            consumed, return_row, next_token = ots_client.get_row(OTS_TABLE_NAME, primary_key)            if not return_row:                return {                    'statusCode': 404,                    'body': json.dumps({'error': '图书不存在'})                }            # 构建更新后的图书属性（保留所有现有字段）            updated_book = {}            for col_name, col_value, col_timestamp in return_row.attribute_columns:                updated_book[col_name] = col_value            # 只更新库存和更新时间（保留封面等所有其他字段）            updated_book['stock'] = stock - 1            updated_book['updated_at'] = int(time.time())            # 构建属性列            attribute_columns = []            for key, value in updated_book.items():                attribute_columns.append((key, value))            # 使用put_row更新整行数据（保留所有字段）            row = Row(primary_key, attribute_columns)            ots_client.put_row(OTS_TABLE_NAME, row, Condition(RowExistenceExpectation.IGNORE))            logger.info(f"库存更新成功: book_id={book_id}, 新库存={stock - 1}")        except OTSServiceError as e:            logger.error(f"OTS服务错误: {e.message}, code={e.code}")            return {                'statusCode': 500,                'body': json.dumps({'error': '库存更新失败'})            }        except Exception as e:            logger.error(f"更新库存失败: {str(e)}", exc_info=True)            return {                'statusCode': 500,                'body': json.dumps({'error': '库存更新失败'})            }        # 创建借阅记录        borrow_id = str(uuid.uuid4())        borrow_data = {            'borrow_id': borrow_id,            'book_id': book_id,            'user_id': user_id,            'borrow_date': int(time.time()),            'due_date': int(time.time()) + days * 24 * 3600,            'status': 'borrowed',            'created_at': int(time.time()),  # 新增            'updated_at': int(time.time())  # 新增        }        try:            borrow_primary_key = [('borrow_id', borrow_id)]            borrow_attribute_columns = [                ('book_id', borrow_data['book_id']),                ('user_id', borrow_data['user_id']),                ('borrow_date', borrow_data['borrow_date']),                ('due_date', borrow_data['due_date']),                ('status', borrow_data['status'])            ]            borrow_row = Row(borrow_primary_key, borrow_attribute_columns)            ots_client.put_row(BORROW_RECORDS_TABLE, borrow_row, Condition(RowExistenceExpectation.IGNORE))            logger.info(f"借阅记录创建成功: borrow_id={borrow_id}")        except Exception as e:            logger.error(f"创建借阅记录失败: {str(e)}", exc_info=True)            # 尝试回滚库存（同样保留所有字段）            try:                # 回滚库存                updated_book['stock'] = stock                updated_book['updated_at'] = int(time.time())                # 构建属性列                rollback_attributes = []                for key, value in updated_book.items():                    rollback_attributes.append((key, value))                # 使用put_row回滚库存（保留所有字段）                rollback_row = Row(primary_key, rollback_attributes)                ots_client.put_row(OTS_TABLE_NAME, rollback_row, Condition(RowExistenceExpectation.IGNORE))                logger.info(f"库存回滚成功: book_id={book_id}")            except Exception as e:                logger.error(f"库存回滚失败: {str(e)}", exc_info=True)            return {                'statusCode': 500,                'body': json.dumps({'error': '借阅记录创建失败'})            }        return {            'statusCode': 200,            'body': json.dumps({                'success': True,                'borrow_id': borrow_id,                'due_date': borrow_data['due_date']            })        }    except Exception as e:        logger.error(f"借阅图书失败 [book_id={book_id}, user_id={user_id}]: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '借阅失败'})        }# 归还图书 - 更新库存和借阅记录状态def return_book(book_id, headers):    try:        user_id = get_current_user_id(headers)        if not user_id:            logger.warning("未授权访问，无法获取用户ID")            return {                'statusCode': 401,                'body': json.dumps({'error': '未授权访问'})            }        # 获取图书当前库存        book_response = get_book(book_id)        if book_response['statusCode'] != 200:            return book_response        try:            book_info = json.loads(book_response['body'])            stock = book_info.get('stock', 0)            try:                stock = int(stock)            except:                stock = 0        except:            stock = 0        # 获取用户的借阅记录（状态为borrowed）        borrow_record = get_borrowing_record(book_id, user_id)        if not borrow_record:            logger.warning(f"未找到借阅记录: book_id={book_id}, user_id={user_id}")            return {                'statusCode': 400,                'body': json.dumps({'error': '未找到借阅记录'})            }        borrow_id = borrow_record.get('borrow_id')        if not borrow_id:            logger.warning("借阅记录中未找到borrow_id")            return {                'statusCode': 500,                'body': json.dumps({'error': '借阅记录格式错误'})            }        # 增加库存        primary_key = [('book_id', book_id)]        update_of_attribute_columns = {            'PUT': [                ('stock', stock + 1),                ('updated_at', int(time.time()))            ]        }        # 创建Row对象        row = Row(primary_key, update_of_attribute_columns)        ots_client.update_row(            OTS_TABLE_NAME,            row,            Condition(RowExistenceExpectation.IGNORE)        )        logger.info(f"库存增加成功: book_id={book_id}, 新库存={stock + 1}")        # 更新借阅记录状态为已归还        borrow_primary_key = [('borrow_id', borrow_id)]        update_borrow_columns = {            'PUT': [                ('status', 'returned'),                ('return_date', int(time.time()))            ]        }        # 创建Row对象        row = Row(borrow_primary_key, update_borrow_columns)        ots_client.update_row(            BORROW_RECORDS_TABLE,            row,            Condition(RowExistenceExpectation.IGNORE)        )        logger.info(f"借阅记录更新为已归还: borrow_id={borrow_id}")        return {            'statusCode': 200,            'body': json.dumps({'success': True})        }    except Exception as e:        logger.error(f"归还图书失败 [book_id={book_id}, user_id={user_id}]: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '归还失败'})        }# 批量借阅 - 复用单个借阅逻辑def batch_borrow_books(body, headers):    try:        user_id = get_current_user_id(headers)        if not user_id:            logger.warning("未授权访问，无法获取用户ID")            return {                'statusCode': 401,                'body': json.dumps({'error': '未授权访问'})            }        book_ids = body.get('book_ids', [])        if not book_ids:            return {                'statusCode': 400,                'body': json.dumps({'error': '请选择要借阅的图书'})            }        results = []        success_count = 0        for book_id in book_ids:            try:                # 调用单个借阅函数                borrow_response = borrow_book(book_id, headers)                if borrow_response['statusCode'] == 200:                    borrow_info = json.loads(borrow_response['body'])                    results.append({                        'book_id': book_id,                        'success': True,                        'borrow_id': borrow_info.get('borrow_id', ''),                        'due_date': borrow_info.get('due_date', '')                    })                    success_count += 1                else:                    error_info = json.loads(borrow_response['body'])                    results.append({                        'book_id': book_id,                        'success': False,                        'error': error_info.get('error', '借阅失败')                    })            except Exception as e:                results.append({                    'book_id': book_id,                    'success': False,                    'error': str(e)                })        return {            'statusCode': 200,            'body': json.dumps({                'success': True,                'borrowed_count': success_count,                'results': results            })        }    except Exception as e:        logger.error(f"批量借阅失败 [user_id={user_id}]: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '批量借阅失败'})        }# 获取用户借阅记录def get_user_borrows(headers):    try:        # 获取当前用户ID        user_id = get_current_user_id(headers)        if not user_id:            return {                'statusCode': 401,                'body': json.dumps({'error': 'Unauthorized'})            }        # 查询借阅记录        start_primary_key = [('borrow_id', INF_MIN)]        end_primary_key = [('borrow_id', INF_MAX)]        condition = SingleColumnCondition(            'user_id',            user_id,            ComparatorType.EQUAL        )        borrow_records = []        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                BORROW_RECORDS_TABLE,                'FORWARD',                next_start_primary_key,                end_primary_key,                max_version=1,                column_filter=condition            )            for row in row_list:                record = {}                for pk in row.primary_key:                    record[pk[0]] = pk[1]                for col in row.attribute_columns:                    record[col[0]] = col[1]                borrow_records.append(record)        # 获取图书信息        for record in borrow_records:            book_id = record.get('book_id')            if book_id:                book_response = get_book(book_id)                # 确保正确解析图书信息                if book_response['statusCode'] == 200:                    try:                        book_info = json.loads(book_response['body'])                        record['book_title'] = book_info.get('title', '未知图书')                        record['book_cover'] = book_info.get('cover', '')  # 添加封面信息                    except Exception as e:                        logger.error(f"解析图书信息失败: {str(e)}")                        record['book_title'] = '未知图书'                else:                    record['book_title'] = '未知图书'            else:                record['book_title'] = '未知图书'        return {            'statusCode': 200,            'body': json.dumps({                'items': borrow_records            })        }    except Exception as e:        logger.error(f"获取借阅记录失败: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': 'Failed to get borrow records'})        }# 批量归还图书def batch_return_books(body, headers):    try:        # 获取当前用户ID        user_id = get_current_user_id(headers)        if not user_id:            return {                'statusCode': 401,                'body': json.dumps({'error': 'Unauthorized'})            }        borrow_ids = body.get('borrow_ids', [])        results = []        for borrow_id in borrow_ids:            # 获取借阅记录            primary_key = [('borrow_id', borrow_id)]            consumed, return_row, next_token = ots_client.get_row(BORROW_RECORDS_TABLE, primary_key)            if not return_row:                results.append({'borrow_id': borrow_id, 'success': False, 'error': '记录不存在'})                continue            # 验证用户权限            record_user_id = None            record_book_id = None            record_status = None            for col_name, col_value, col_timestamp in return_row.attribute_columns:                if col_name == 'user_id':                    record_user_id = col_value                elif col_name == 'book_id':                    record_book_id = col_value                elif col_name == 'status':                    record_status = col_value            if record_user_id != user_id:                results.append({'borrow_id': borrow_id, 'success': False, 'error': '无权操作'})                continue            # 检查是否已归还            if record_status != 'borrowed':                results.append({'borrow_id': borrow_id, 'success': False, 'error': '记录已归还'})                continue            # 获取图书ID            if not record_book_id:                results.append({'borrow_id': borrow_id, 'success': False, 'error': '无效的图书ID'})                continue            # 归还图书            return_response = return_book(record_book_id, headers)            if return_response['statusCode'] == 200:                # 更新借阅记录状态                update_of_attribute_columns = {                    'PUT': [                        ('status', 'returned'),                        ('return_date', int(time.time()))                    ]                }                # 创建Row对象                row = Row(primary_key, update_of_attribute_columns)                ots_client.update_row(                    BORROW_RECORDS_TABLE,                    row,                    Condition(RowExistenceExpectation.IGNORE)                )                results.append({'borrow_id': borrow_id, 'success': True})            else:                error_info = json.loads(return_response['body'])                results.append({                    'borrow_id': borrow_id,                    'success': False,                    'error': error_info.get('error', '归还失败')                })        return {            'statusCode': 200,            'body': json.dumps({                'success': True,                'results': results            })        }    except Exception as e:        logger.error(f"批量归还失败: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '批量归还失败'})        }# 通过借阅记录ID归还图书def return_book_by_borrow_id(borrow_id, headers):    try:        # 获取当前用户ID        user_id = get_current_user_id(headers)        if not user_id:            return {                'statusCode': 401,                'body': json.dumps({'error': 'Unauthorized'})            }        # 获取借阅记录        primary_key = [('borrow_id', borrow_id)]  # 这里已经定义了 primary_key        consumed, return_row, next_token = ots_client.get_row(BORROW_RECORDS_TABLE, primary_key)        if not return_row:            return {                'statusCode': 404,                'body': json.dumps({'error': '借阅记录不存在'})            }        # 验证用户权限        record_user_id = None        record_book_id = None        record_status = None        for col_name, col_value, col_timestamp in return_row.attribute_columns:            if col_name == 'user_id':                record_user_id = col_value            elif col_name == 'book_id':                record_book_id = col_value            elif col_name == 'status':                record_status = col_value        if record_user_id != user_id:            return {                'statusCode': 403,                'body': json.dumps({'error': '无权操作此借阅记录'})            }        # 检查是否已归还        if record_status != 'borrowed':            return {                'statusCode': 400,                'body': json.dumps({'error': '借阅记录已归还'})            }        # 获取图书ID        if not record_book_id:            return {                'statusCode': 400,                'body': json.dumps({'error': '无效的图书ID'})            }        # 归还图书        return_response = return_book(record_book_id, headers)        if return_response['statusCode'] == 200:            # 更新借阅记录状态            update_of_attribute_columns = {                'PUT': [                    ('status', 'returned'),                    ('return_date', int(time.time()))                ]            }            # 创建Row对象 - 使用已定义的 primary_key            row = Row(primary_key, update_of_attribute_columns)  # 这里使用 primary_key 而不是 borrow_primary_key            ots_client.update_row(                BORROW_RECORDS_TABLE,                row,                Condition(RowExistenceExpectation.IGNORE)            )            return {                'statusCode': 200,                'body': json.dumps({'success': True})            }        else:            return return_response    except Exception as e:        logger.error(f"通过借阅ID归还图书失败: {str(e)}", exc_info=True)        return {            'status极Code': 500,            'body': json.dumps({'error': '归还失败'})        }# 新增：获取所有图书数据用于AI知识库def get_all_books_for_ai():    """获取所有图书数据用于AI知识库"""    try:        books = []        start_极primary_key = [('book_id', INF_MIN)]        end_primary_key = [('book_id', INF_MAX)]        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                OTS_TABLE_NAME,                'FORWARD',                next_start_primary_key,                end_primary_key,                limit=100,                max_version=1            )            for row in row_list:                book = {}                for pk in row.primary_key:                    book[pk[0]] = pk[1]                for col in row.attribute_columns:                    book[col[0]] = col[1]                # 只提取AI需要的信息                books.append({                    'title': book.get('title', ''),                    'author': book.get('author', ''),                    'category': book.get('category', ''),                    'description': book.get('description', '')[:200] + '...' if book.get('description') and len(                        book.get('description')) > 200 else book.get('description', ''),                    'status': book.get('status', ''),                    'stock': book.get('stock', 0)                })        return books    except Exception as e:        logger.error(f"获取AI图书数据失败: {str(e)}", exc_info=True)        return []# 新增：使用DeepSeek API处理消息def process_with_deepseek(message, books_data, user_id):    """使用DeepSeek API处理消息"""    # 构建系统提示词    system_prompt = f"""你是一个图书管理AI助手，名为"FluxLib助手"。请根据以下图书信息回答用户问题：可用图书列表:{json.dumps(books_data, ensure_ascii=False, indent=2)}请遵循以下规则:1. 只能推荐上述列表中的图书，不能编造不存在的图书2. 对于图书内容相关问题，基于图书描述信息回答3. 图书馆运营时间: 周一至周五 9:00-21:00, 周末 10:00-18:004. 借阅规则: 每次最多借阅5本，借期30天，可续借一次5. 保持友好、专业的语气6. 如果问题与图书无关，礼貌地表示你专注于图书相关问题7. 回答要简洁明了，突出重点信息当前时间: {time.strftime('%Y-%m-%d %H:%M:%S')}"""    try:        # DeepSeek API调用        url = "https://api.deepseek.com/v1/chat/completions"        headers = {            "Authorization": f"Bearer {DEEPSEEK_API_KEY}",            "Content-Type": "application/json"        }        payload = {            "model": "deepseek-chat",            "messages": [                {"role": "system", "content": system_prompt},                {"role": "user", "content": message}            ],            "temperature": 0.7,            "max_tokens": 2000,            "stream": False        }        response = requests.post(url, headers=headers, json=payload, timeout=30)        response_data = response.json()        if response.status_code == 200:            return response_data['choices'][0]['message']['content']        else:            logger.error(f"DeepSeek API错误: {response_data}")            return "抱歉，我现在遇到了一些技术问题，请稍后再试。"    except requests.exceptions.Timeout:        logger.error("DeepSeek API请求超时")        return "请求超时，请稍后再试。"    except Exception as e:        logger.error(f"DeepSeek调用失败: {str(e)}")        return "处理您的请求时出现了问题，请稍后再试。"# 新增：添加收藏def add_favorite(user_id, book_id):    try:        favorite_id = str(uuid.uuid4())        current_time = int(time.time())        primary_key = [('favorite_id', favorite_id)]        attribute_columns = [            ('user_id', user极_id),            ('book_id', book_id),            ('created_at', current_time),  # 原有            ('updated_at', current_time)  # 新增        ]        row = Row(primary_key, attribute_columns)        ots_client.put_row(FAVORITES_TABLE, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"添加收藏成功: user_id={user_id}, book_id={book_id}")        return True    except Exception as e:        logger.error(f"添加收藏失败: {str(e)}", exc_info=True)        return False# 新增：移除收藏def remove_favorite(user_id, book_id):    try:        # 查找收藏记录        start_primary_key = [('favorite_id', INF_MIN)]        end_primary_key = [('favorite_id', INF_MAX)]        # 创建复合条件：用户ID + 图书ID        composite_condition = CompositeColumnCondition(LogicalOperator.AND)        composite_condition.add_sub_condition(            SingleColumnCondition('user_id', user_id, ComparatorType.EQUAL)        )        composite_condition.add_sub_condition(            SingleColumnCondition('book_id', book_id, ComparatorType.EQUAL)        )        consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(            FAVORITES_TABLE,            'FORWARD',            start_primary_key,            end_primary_key,            max_version=1,            column_filter=composite_condition,            limit=1        )        if not row_list:            return False        # 删除收藏记录        favorite_id = None        for pk in row_list[0].primary_key:            if pk[0] == 'favorite_id':                favorite_id = pk[1]                break        if favorite_id:            primary_key = [('favorite_id', favorite_id)]            ots_client.delete_row(FAVORITES_TABLE, primary_key, Condition(RowExistenceExpectation.IGNORE))            logger.info(f"移除收藏成功: user_id={user_id}, book_id={book_id}")            return True        return False    except Exception as e:        logger.error(f"移除收藏失败: {str(e)}", exc_info=True)        return False# 新增：检查是否已收藏def check_favorite(user_id, book_id):    try:        start_primary_key = [('favorite_id', INF_MIN)]        end_primary_key = [('favorite_id', INF_MAX)]        # 创建复合条件：用户ID + 图书ID        composite_condition = CompositeColumnCondition(LogicalOperator.AND)        composite_condition.add_sub_condition(            SingleColumnCondition('user_id', user_id, ComparatorType.EQUAL)        )        composite_condition.add_sub_condition(            SingleColumnCondition('book_id', book_id, ComparatorType.EQUAL)        )        consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(            FAVORITES_TABLE,            'FORWARD',            start_primary_key,            end_primary_key,            max_version=1,            column_filter=composite_condition,            limit=1        )        return len(row_list) > 0    except Exception as e:        logger.error(f"检查收藏状态失败: {str(e)}", exc_info=True)        return False# 新增：获取用户收藏列表def get_user_favorites(user_id):    try:        favorites = []        start_primary_key = [('favorite_id', INF_MIN)]        end_primary_key = [('favorite_id', INF_MAX)]        condition = SingleColumnCondition(            'user_id',            user_id,            ComparatorType.EQUAL        )        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                FAVORITES_TABLE,                'FORWARD',                next_start_primary_key,                end_primary_key,                max_version=1,                column_filter=condition            )            for row in row_list:                favorite = {}                for pk in row.primary_key:                    favorite[pk[0]] = pk[1]                for col in row.attribute_columns:                    favorite[col[0]] = col[1]                # 获取图书信息                book_id = favorite.get('book_id')                if book_id:                    book_response = get_book(book_id)                    if book_response['statusCode'] == 200:                        try:                            book_info = json.loads(book_response['body'])                            favorite['book_title'] = book_info.get('title', '未知图书')                            favorite['book_cover'] = book_info.get('cover', '')                            favorite['book_author'] = book_info.get('author', '未知作者')                        except Exception as e:                            logger.error(f"解析图书信息失败: {str(e)}")                            favorite['book_title'] = '未知图书'                    else:                        favorite['book_title'] = '未知图书'                favorites.append(favorite)        return favorites    except Exception as e:        logger.error(f"获取收藏列表失败: {str(e)}", exc_info=True)        return []# 新增：添加浏览历史def add_view_history(user_id, book_id):    try:        history_id = str(uuid.uuid4())        view_time = int(time.time())  # 先定义 view_time 变量        primary_key = [('history_id', history_id)]        attribute_columns = [            ('user_id', user_id),            ('book_id', book_id),            ('view_time', view_time),            ('created_at', view_time),  # 使用已定义的 view_time            ('updated_at', view_time)  # 使用已定义的 view_time        ]        row = Row(primary_key, attribute_columns)        ots_client.put_row(VIEW_HISTORY_TABLE, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"添加浏览历史成功: user_id={user_id}, book_id={book_id}")        return True    except Exception as e:        logger.error(f"添加浏览历史失败: {str(e)}", exc_info=True)        return False# 新增：获取用户浏览历史def get_user_view_history(user_id):    try:        history = []        start_primary_key = [('history_id', INF_MIN)]        end_primary极_key = [('history_id', INF_MAX)]        condition = SingleColumnCondition(            'user_id',            user_id,            ComparatorType.EQUAL        )        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                VIEW_HISTORY_TABLE,                'FORWARD',                next_start_primary_key,                end_primary_key,                max_version=1,                column_filter=condition            )            for row in row_list:                record = {}                for pk in row.primary_key:                    record[pk[0]] = pk[1]                for col in row.attribute_columns:                    record[col[0]] = col[1]                # 获取图书信息                book_id = record.get('book_id')                if book_id:                    book_response = get_book(book_id)                    if book_response['statusCode'] == 200:                        try:                            book_info = json.loads(book_response['body'])                            record['book_title'] = book_info.get('title', '未知图书')                            record['book_cover'] = book_info.get('cover', '')                            record['book_author'] = book_info.get('author', '未知作者')                        except Exception as e:                            logger.error(f"解析图书信息失败: {str(e)}")                            record['book_title'] = '未知图书'                    else:                        record['book_title'] = '未知图书'                history.append(record)        # 按浏览时间倒序排序        history.sort(key=lambda x: x.get('view_time', 0), reverse=True)        return history    except Exception as e:        logger.error(f"获取浏览历史失败: {str(e)}", exc_info=True)        return []# 新增：获取公告列表def get_announcements():    try:        announcements = []        start_primary_key = [('announcement_id', INF_MIN)]        end_primary_key = [('announcement_id', INF_MAX)]        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                ANNOUNCEMENTS_TABLE,                'FORWARD',                next_start_primary_key,                end_primary_key,                max_version=1            )            for row in row_list:                announcement = {}                for pk in row.primary_key:                    announcement[pk[0]] = pk[1]                for col in row.attribute_columns:                    announcement[col[0]] = col[1]                announcements.append(announcement)        # 按发布时间倒序排序        announcements.sort(key=lambda x: x.get('publish_time', 0), reverse=True)        return announcements    except Exception as e:        logger.error(f"获取公告失败: {str(e)}", exc_info=True)        return []# 新增：创建公告def create_announcement(title, content):    try:        announcement_id = str(uuid.uuid4())        primary_key = [('announcement_id', announcement_id)]        attribute_columns = [            ('title', title),            ('content', content),            ('publish_time', current_time),            ('created_at', current_time),            ('updated_at', current_time)        ]        row = Row(primary_key, attribute_columns)        ots_client.put_row(ANNOUNCEMENTS_TABLE, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"创建公告成功: {title}")        return True    except Exception as e:        logger.error(f"创建公告失败: {str(e)}", exc_info=True)        return False# 新增：删除公告def delete_announcement(announcement_id):    try:        primary_key = [('announcement_id', announcement_id)]        ots_client.delete_row(ANNOUNCEMENTS_TABLE, primary_key, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"删除公告成功: {announcement_id}")        return True    except Exception as e:        logger.error(f"删除公告失败: {str(e)}", exc_info=True)        return False# 创建评论def create_comment(book_id, user_id, content, parent_id=None):    try:        comment_id = str(uuid.uuid4())        created_at = int(time.time())        # 获取用户信息        user = get_user_by_id(user_id)        if not user:            return None, "用户不存在"        # 确保所有字段都有有效值，不能为 None        comment_data = {            'comment_id': comment_id,            'book_id': book_id,            'user_id': user_id,            'user_display_name': user.get('display_name', user.get('email', '未知用户')),            'user_avatar_url': user.get('avatar_url', ''),            'content': content,            'likes': 0,            'created_at': created_at,            'updated_at': created_at,  # 新增            'parent_id': parent_id if parent_id else ''        }        # 移除任何可能为 None 的值        for key in list(comment_data.keys()):            if comment_data[key] is None:                comment_data[key] = ''  # 或者适当的默认值        primary_key = [('comment_id', comment_id)]        attribute_columns = []        for key, value in comment_data.items():            if key != 'comment_id':                attribute_columns.append((key, value))        row = Row(primary_key, attribute_columns)        ots_client.put_row(COMMENTS_TABLE, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"创建评论成功: {comment_id}")        return comment_data, None    except Exception as e:        logger.error(f"创建评论失败: {str(e)}", exc_info=True)        return None, str(e)# 获取图书评论def get_book_comments(book_id):    try:        comments = []        # 使用全表扫描，然后在内存中过滤        start_primary_key = [('comment_id', INF_MIN)]        end_primary_key = [('comment_id', INF_MAX)]        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                COMMENTS_TABLE,                'FORWARD',                next_start_primary_key,                end_primary_key,                max_version=1            )            for row in row_list:                comment = {}                for pk in row.primary_key:                    comment[pk[0]] = pk[1]                for col in row.attribute_columns:                    comment[col[0]] = col[1]                # 确保所有字段都有默认值                comment.setdefault('user_display_name', '未知用户')                comment.setdefault('user_avatar_url', '')                comment.setdefault('content', '')                comment.setdefault('likes', 0)                comment.setdefault('parent_id', '')                # 过滤出当前图书的评论                if comment.get('book_id') == book_id:                    comments.append(comment)        # 按点赞数排序（降序）        comments.sort(key=lambda x: x.get('likes', 0), reverse=True)        # 构建评论树结构        comment_tree = []        comment_map = {}        # 第一遍，创建所有评论的映射        for comment in comments:            comment_id = comment['comment_id']            comment_map[comment_id] = comment            comment['replies'] = []  # 初始化回复列表        # 第二遍，构建树结构        for comment in comments:            parent_id = comment.get('parent_id')            if parent_id and parent_id in comment_map:                # 这是回复评论，添加到父评论的回复列表中                comment_map[parent_id]['replies'].append(comment)            else:                # 这是顶级评论，添加到评论树中                comment_tree.append(comment)        return comment_tree    except Exception as e:        logger.error(f"获取评论失败: {str(e)}", exc_info=True)        return []# 点赞评论def like_comment(comment_id):    try:        # 获取当前评论        primary_key = [('comment_id', comment_id)]        consumed, return_row, next_token = ots_client.get_row(COMMENTS_TABLE, primary_key)        if not return_row:            return False, "评论不存在"        # 提取当前点赞数        current_likes = 0        for col_name, col_value, col_timestamp in return_row.attribute_columns:            if col_name == 'likes':                current_likes = col_value                break        # 更新点赞数        update_of_attribute_columns = {            'PUT': [                ('likes', current_likes + 1),                ('updated_at', int(time.time()))  # 新增            ]        }        row = Row(primary_key, update_of_attribute_columns)        ots_client.update_row(COMMENTS_TABLE, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"点赞评论成功: {comment_id}")        return True, None    except Exception as e:        logger.error(f"点赞评论失败: {str(e)}", exc_info=True)        return False, str(e)# 更新用户信息def update_user_profile(user_id, display_name=None, avatar_url=None, gender=None):    try:        # 获取用户信息        user = get_user_by_id(user_id)        if not user:            return False, "用户不存在"        # 构建更新字段        update_of_attribute_columns = {'PUT': []}        if display_name:            update_of_attribute_columns['PUT'].append(('display_name', display_name))        if avatar_url:            update_of_attribute_columns['PUT'].append(('avatar_url', avatar_url))        if gender:            update_of_attribute_columns['PUT'].append(('gender', gender))        if not update_of_attribute_columns['PUT']:            return False, "没有提供更新字段"        # 使用邮箱作为主键更新用户信息        primary_key = [('email', user['email'])]        row = Row(primary_key, update_of_attribute_columns)        ots_client.update_row(USERS_TABLE, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"更新用户信息成功: {user_id}")        return True, None    except Exception as e:        logger.error(f"更新用户信息失败: {str(e)}", exc_info=True)        return False, str(e)# API路由@app.route("/", methods=["GET"])def index():    return {"message": "Backend is running"}, 200@app.route('/health')def health_check():    return 'OK', 200@app.route('/send-verification-code', methods=['POST'])def handle_send_verification_code():    data = request.get_json()    email = data.get('email')    if not email:        return jsonify({'error': 'Email is required'}), 400    success = send_verification_code(email)    if success:        return jsonify({'message': 'Verification code sent'}), 200    else:        return jsonify({'error': 'Failed to send verification code'}), 500@app.route('/register', methods=['POST'])def handle_register():    data = request.get_json()    email = data.get('email')    password = data.get('password')    code = data.get('code')    if not email or not password or not code:        return jsonify({'error': 'Email, password and code are required'}), 400    success, result = register_user(email, password, code)    if success:        return jsonify({'user_id': result}), 201    else:        return jsonify({'error': result}), 400@app.route('/login', methods=['POST'])def handle_login():    data = request.get_json()    email = data.get('email')    password = data.get('password')    admin_code = data.get('admin_code')    if not email or not password:        return jsonify({'error': '邮箱和密码是必填项'}), 400    success, result = login_user(email, password, admin_code)    if success:        # 生成 token（这里使用 user_id 作为 token）        token = result['user_id']        return jsonify({            'token': token,            'user_id': result['user_id'],            'email': email,            'role': result['role'],            'is_admin': result.get('is_admin', False)        }), 200    else:        if result == "管理员码错误":            return jsonify({'error': result}), 403        else:            return jsonify({'error': result}), 401@app.route('/books', methods=['GET'])def handle_get_books():    page = request.args.get('page', default=1, type=int)    size = request.args.get('极size', default=10, type=int)    return get_books(page, size)@app.route('/books', methods=['POST'])def handle_create_book():    # 检查用户权限    user_id = get_current_user_id(request.headers)    if not user_id:        return jsonify({'error': '未授权访问'}), 401    user = get_user_by_id(user_id)    if not user or user.get('role') != 'admin':        return jsonify({'error': '需要管理员权限'}), 403    data = request.get_json()    return create_book(data)@app.route('/books/<book_id>', methods=['GET'])def handle_get_book(book_id):    # 记录浏览历史    user_id = get_current_user_id(request.headers)    if user_id:        add_view_history(user_id, book_id)    return get_book(book_id)@app.route('/books/<book_id>', methods=['PUT'])def handle_update_book(book_id):    # 检查用户权限    user_id = get_current_user_id(request.headers)    if not user_id:        return jsonify({'error': '未授权访问'}), 401    user = get_user_by_id(user_id)    if not user or user.get('role') != 'admin':        return jsonify({'error': '需要管理员权限'}), 403    data = request.get_json()    return update_book(book_id, data)@app.route('/books/<book_id>', methods=['DELETE'])def handle_delete_book(book_id):    try:        # 获取用户ID        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        # 获取用户信息        user = get_user_by_id(user_id)        if not user:            return jsonify({'error': '用户不存在'}), 404        # 检查用户角色        logger.info(f"删除图书权限检查: user_id={user_id}, role={user.get('role')}")        # 确保正确检查管理员权限        if user.get('role') != 'admin':            logger.warning(f"权限不足: 用户 {user_id} 角色 {user.get('role')} 不是管理员")            return jsonify({'error': '需要管理员权限'}), 403        # 调用删除函数并处理响应        result = delete_book(book_id)        # 如果返回的是字典（包含 statusCode 和 body），则提取 body 并返回        if isinstance(result, dict) and 'body' in result:            response_data = json.loads(result['body'])            status_code = result.get('statusCode', 200)            return jsonify(response_data), status_code        else:            # 如果返回的是其他格式，直接返回            return result    except Exception as e:        logger.error(f"删除图书失败: {str(e)}", exc_info=True)        return jsonify({'error': '删除失败'}), 500@app.route('/presigned-url', methods=['GET'])def handle_presigned_url():    file_name = request.args.get('file_name')    file_type = request.args.get('file_type')    return generate_presigned_url(file_name, file_type)@app.route('/books/<book_id>/borrow', methods=['POST'])def handle_borrow_book(book_id):    # 获取借阅期限参数    data = request.get_json()    days = data.get('days', 30)  # 默认为30天    return borrow_book(book_id, request.headers, days)@app.route('/books/<book_id>/return', methods=['POST'])def handle_return_book(book_id):    return return_book(book_id, request.headers)@app.route('/books/batch-borrow', methods=['POST'])def handle_batch_borrow():    try:        data = request.get_json()        if not data:            return jsonify({'error': '请求体为空'}), 400        return batch_borrow_books(data, request.headers)    except Exception as e:        logger.error(f"解析批量借阅请求失败: {str(e)}")        return jsonify({'error': '无效的JSON请求体'}), 400# 获取用户借阅记录@app.route('/user/borrows', methods=['GET'])def handle_get_user_borrows():    return get_user_borrows(request.headers)# 批量归还图书@app.route('/batch-return', methods=['POST'])def handle_batch_return():    try:        data = request.get_json()        if not data:            return jsonify({'error': '请求体为空'}), 400        return batch_return_books(data, request.headers)    except Exception as e:        logger.error(f"解析批量归还请求失败: {str(e)}")        return jsonify({'error': '无效的JSON请求体'}), 400# 通过借阅记录ID归还图书@app.route('/return/<borrow_id>', methods=['POST'])def handle_return_by_borrow_id(borrow_id):    return return_book_by_borrow_id(borrow_id, request.headers)# 新增：AI聊天路由@app.route('/ai/chat', methods=['POST'])def handle_ai_chat():    try:        data = request.get_json()        user_message = data.get('message', '')        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        if not user_message:            return jsonify({'error': '消息不能为空'}), 400        # 获取图书数据用于构建知识库        books_data = get_all_books_for_ai()        # 调用AI处理函数        response = process_with_deepseek(user_message, books_data, user_id)        return jsonify({            'response': response,            'timestamp': int(time.time())        })    except Exception as e:        logger.error(f"AI聊天处理失败: {str(e)}", exc_info=True)        return jsonify({'error': '处理请求时发生错误'}), 500# 新增：添加收藏@app.route('/favorites/<book_id>', methods=['POST'])def handle_add_favorite(book_id):    try:        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        success = add_favorite(user_id, book_id)        if success:            return jsonify({'success': True}), 200        else:            return jsonify({'error': '添加收藏失败'}), 500    except Exception as e:        logger.error(f"添加收藏失败: {str(e)}", exc_info=True)        return jsonify({'error': '添加收藏失败'}), 500# 新增：移除收藏@app.route('/favorites/<book_id>', methods=['DELETE'])def handle_remove_favorite(book_id):    try:        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        success = remove_favorite(user_id, book_id)        if success:            return jsonify({'success': True}), 200        else:            return jsonify({'error': '移除收藏失败'}), 500    except Exception as e:        logger.error(f"移除收藏失败: {str(e)}", exc_info=True)        return jsonify({'error': '移除收藏失败'}), 500# 新增：检查收藏状态@app.route('/favorites/<book_id>/check', methods=['GET'])def handle_check_favorite(book_id):    try:        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        is_favorited = check_favorite(user_id, book_id)        return jsonify({'is_favorited': is_favorited}), 200    except Exception as e:        logger.error(f"检查收藏状态失败: {str(e)}", exc_info=True)        return jsonify({'error': '检查收藏状态失败'}), 500# 新增：获取用户收藏列表@app.route('/favorites', methods=['GET'])def handle_get_favorites():    try:        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        favorites = get_user_favorites(user_id)        return jsonify(favorites), 200    except Exception as e:        logger.error(f"获取收藏列表失败: {str(e)}", exc_info=True)        return jsonify({'error': '获取收藏列表失败'}), 500# 新增：获取用户浏览历史@app.route('/history', methods=['GET'])def handle_get_view_history():    try:        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        history = get_user_view_history(user_id)        return jsonify(history), 200    except Exception as e:        logger.error(f"获取浏览历史失败: {str(e)}", exc_info=True)        return jsonify({'error': '获取浏览历史失败'}), 500# 新增：获取公告列表@app.route('/announcements', methods=['GET'])def handle_get_announcements():    try:        announcements = get_announcements()        return jsonify(announcements), 200    except Exception as e:        logger.error(f"获取公告失败: {str(e)}", exc_info=True)        return jsonify({'error': '获取公告失败'}), 500# 新增：创建公告（管理员权限）@app.route('/announcements', methods=['POST'])def handle_create_announcement():    try:        # 检查用户权限        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        user = get_user_by_id(user_id)        if not user or user.get('role') != 'admin':            return jsonify({'error': '需要管理员权限'}), 403        data = request.get_json()        title = data.get('title')        content = data.get('content')        if not title or not content:            return jsonify({'error': '标题和内容不能为空'}), 400        success = create_announcement(title, content)        if success:            return jsonify({'success': True}), 200        else:            return jsonify({'error': '创建公告失败'}), 500    except Exception as e:        logger.error(f"创建公告失败: {str(e)}", exc_info=True)        return jsonify({'error': '创建公告失败'}), 500# 新增：删除公告（管理员权限）@app.route('/announcements/<announcement_id>', methods=['DELETE'])def handle_delete_announcement(announcement_id):    try:        # 检查用户权限        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        user = get_user_by_id(user_id)        if not user or user.get('role') != 'admin':            return jsonify({'error': '需要管理员权限'}), 403        success = delete_announcement(announcement_id)        if success:            return jsonify({'success': True}), 200        else:            return jsonify({'error': '删除公告失败'}), 500    except Exception as e:        logger.error(f"删除公告失败: {str(e)}", exc_info=True)        return jsonify({'error': '删除公告失败'}), 500# 获取图书评论@app.route('/books/<book_id>/comments', methods=['GET'])def handle_get_comments(book_id):    try:        comments = get_book_comments(book_id)        return jsonify(comments), 200    except Exception as e:        logger.error(f"获取评论失败: {str(e)}", exc_info=True)        return jsonify({'error': '获取评论失败'}), 500# 创建评论@app.route('/books/<book_id>/comments', methods=['POST'])def handle_create_comment(book_id):    try:        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        data = request.get_json()        content = data.get('content')        parent_id = data.get('parent_id')  # 可选，如果是回复评论        if not content:            return jsonify({'error': '评论内容不能为空'}), 400        comment, error = create_comment(book_id, user_id, content, parent_id)        if error:            return jsonify({'error': error}), 500        return jsonify(comment), 201    except Exception as e:        logger.error(f"创建评论失败: {str(e)}", exc_info=True)        return jsonify({'error': '创建评论失败'}), 500# 点赞评论@app.route('/comments/<comment_id>/like', methods=['POST'])def handle_like_comment(comment_id):    try:        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        success, error = like_comment(comment_id)        if not success:            return jsonify({'error': error}), 400        return jsonify({'success': True}), 200    except Exception as e:        logger.error(f"点赞评论失败: {str(e)}", exc_info=True)        return jsonify({'error': '点赞失败'}), 500# 修改更新用户信息函数，支持文件上传def update_user_profile(user_id, display_name=None, avatar_file=None):    try:        # 获取用户信息        user = get_user_by_id(user_id)        if not user:            return False, "用户不存在"        # 如果有上传头像文件，先上传到OSS        avatar_url = user.get('avatar_url', '')        if avatar_file:            # 生成唯一的文件名            file_extension = avatar_file.filename.split('.')[-1] if '.' in avatar_file.filename else 'jpg'            unique_filename = f"user-avatars/{user_id}.{file_extension}"            # 上传到OSS            try:                oss_bucket.put_object(unique_filename, avatar_file)                avatar_url = f"https://{OSS_BUCKET_NAME}.{OSS_ENDPOINT.replace('https://', '')}/{unique_filename}"            except Exception as e:                logger.error(f"上传头像失败: {str(e)}")                return False, "上传头像失败"        # 构建更新字段        update_of_attribute_columns = {'PUT': [('updated_at', int(time.time()))]}  # 新增：强制更新updated_at        if display_name:            update_of_attribute_columns['PUT'].append(('display_name', display_name))        if avatar_url:            update_of_attribute_columns['PUT'].append(('avatar_url', avatar_url))        if gender:            update_of_attribute_columns['PUT'].append(('gender', gender))        if not update_of_attribute_columns['PUT']:            return False, "没有提供更新字段"        # 使用邮箱作为主键更新用户信息        primary_key = [('email', user['email'])]        row = Row(primary_key, update_of_attribute_columns)        ots_client.update_row(USERS_TABLE, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"更新用户信息成功: {user_id}")        return True, None    except Exception as e:        logger.error(f"更新用户信息失败: {str(e)}", exc_info=True)        return False, str(e)# 修改更新用户信息的API路由，支持文件上传@app.route('/user/profile', methods=['PUT'])def handle_update_profile():    try:        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        # 检查是否是表单数据（包含文件）        if request.content_type.startswith('multipart/form-data'):            display_name = request.form.get('display_name')            avatar_file = request.files.get('avatar')            success, error = update_user_profile(user_id, display_name, avatar_file)        else:            # 处理JSON数据（兼容旧版本）            data = request.get_json()            display_name = data.get('display_name')            avatar_url = data.get('avatar_url')            success, error = update_user_profile(user_id, display_name, avatar_url)        if not success:            return jsonify({'error': error}), 400        return jsonify({'success': True}), 200    except Exception as e:        logger.error(f"更新用户信息失败: {str(e)}", exc_info=True)        return jsonify({'error': '更新失败'}), 500# 获取当前用户信息def get_current_user_info(user_id):    try:        user = get_user_by_id(user_id)        if not user:            return None, "用户不存在"        # 返回用户信息（排除敏感信息如密码）        user_info = {            'user_id': user.get('user_id'),            'email': user.get('email'),            'display_name': user.get('display_name', ''),            'avatar_url': user.get('avatar_url', ''),            'role': user.get('role', 'user'),            'is_admin': user.get('role') == 'admin',            'created_at': user.get('created_at', 0)        }        return user_info, None    except Exception as e:        logger.error(f"获取用户信息失败: {str(e)}", exc_info=True)        return None, str(e)# 添加获取当前用户信息的API路由@app.route('/user/current', methods=['GET'])def handle_get_current_user():    try:        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        user_info, error = get_current_user_info(user_id)        if error:            return jsonify({'error': error}), 404        return jsonify(user_info), 200    except Exception as e:        logger.error(f"获取当前用户信息失败: {str(e)}", exc_info=True)        return jsonify({'error': '获取用户信息失败'}), 500# 预约借阅图书@app.route('/books/<book_id>/reserve', methods=['POST'])def handle_reserve_book(book_id):    try:        data = request.get_json()        reserve_date = data.get('reserve_date')        time_slot = data.get('time_slot')        days = data.get('days', 30)        if not reserve_date or not time_slot:            return jsonify({'error': '预约日期和时间段是必填项'}), 400        return reserve_book(book_id, request.headers, reserve_date, time_slot, days)    except Exception as e:        logger.error(f"处理预约请求失败: {str(e)}")        return jsonify({'error': '无效的JSON请求体'}), 400# 提前归还图书@app.route('/books/<book_id>/return-early', methods=['POST'])def handle_return_early(book_id):    try:        # 这里可以添加确认逻辑，比如前端应该先弹出确认对话框        # 确认后再调用此接口        return return_book(book_id, request.headers, is_early_return=True)    except Exception as e:        logger.error(f"处理提前归还请求失败: {str(e)}")        return jsonify({'error': '归还失败'}), 500# 辅助函数：通过用户ID获取用户信息def get_user_by_id(user_id):    try:        # 由于用户表的主键是 email，我们需要通过扫描来找到匹配的用户        # 创建一个条件：user_id 等于指定的 user_id        condition = SingleColumnCondition(            'user_id',            user_id,            ComparatorType.EQUAL        )        # 扫描用户表        start_primary_key = [('email', INF_MIN)]        end_primary_key = [('email', INF_MAX)]        # 初始化 next_start_primary_key        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                USERS_TABLE,                'FORWARD',                next_start_primary_key,                end_primary_key,                max_version=1,                column_filter=condition,                limit=1  # 只获取一条记录            )            if row_list and len(row_list) > 0:                # 提取用户信息                user = {}                for pk in row_list[0].primary_key:                    user[pk[0]] = pk[1]                for col in row_list[0].attribute_columns:                    user[col[0]] = col[1]                logger.info(f"通过ID找到用户: {user.get('email')}, 角色: {user.get('role')}")                # 确保返回的用户信息包含性别字段                return user        logger.warning(f"未找到用户: user_id={user_id}")        return None    except Exception as e:        logger.error(f"通过用户ID获取用户信息失败: {str(e)}", exc_info=True)        return None# 主函数if __name__ == "__main__":    create_admin_user()    port = int(os.getenv('FC_SERVER_PORT', '9000'))    app.run(host='0.0.0.0', port=port)