import osimport jsonimport uuidimport timeimport randomimport smtplibimport hashlibimport loggingimport requestsfrom email.mime.text import MIMETextfrom tablestore import OTSClient, Row, Condition, RowExistenceExpectation, INF_MIN, INF_MAX, SingleColumnCondition, \    ComparatorType, CompositeColumnCondition, LogicalOperatorfrom tablestore.error import OTSServiceErrorfrom tablestore.metadata import TableMeta, TableOptions, ReservedThroughput, CapacityUnitimport oss2from flask import Flask, request, jsonifyfrom functools import wraps# 配置日志logging.basicConfig(level=logging.INFO)logger = logging.getLogger()# 获取环境变量def get_env(key, default=None):    value = os.getenv(key, default)    if value is None:        logger.error(f"环境变量 {key} 未设置!")    return value# 读取环境变量OTS_INSTANCE_NAME = get_env('OTS_INSTANCE_NAME', 'book-mgmt-ots')OTS_ENDPOINT = get_env('OTS_ENDPOINT', 'https://book-mgmt-ots.cn-hangzhou.ots.aliyuncs.com')OTS_TABLE_NAME = get_env('OTS_TABLE_NAME', 'Books')USERS_TABLE = get_env('USERS_TABLE', 'Users')VERIFICATION_CODES_TABLE = get_env('VERIFICATION_CODES_TABLE', 'VerificationCodes')BORROW_RECORDS_TABLE = get_env('BORROW_RECORDS_TABLE', 'BorrowRecords')OSS_BUCKET_NAME = get_env('OSS_BUCKET_NAME', 'book-mgmt-images')OSS_ENDPOINT = get_env('OSS_ENDPOINT', 'https://oss-cn-hangzhou.aliyuncs.com').strip()ALIYUN_ACCESS_KEY = get_env('ALIYUN_ACCESS_KEY', 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxx')ALIYUN_ACCESS_SECRET = get_env('ALIYUN_ACCESS_SECRET', 'xxxxxxxxxxxxxxxxxxxxxxxxx')ALIYUN_REGION = get_env('ALIYUN_REGION', 'cn-hangzhou')EMAIL_HOST = get_env('EMAIL_HOST', 'smtp.qq.com')EMAIL_PORT = int(get_env('EMAIL_PORT', '465'))EMAIL_USER = get_env('EMAIL_USER', 'xxxxxxxxxxxxxxxx@qq.com')EMAIL_PASSWORD = get_env('EMAIL_PASSWORD', 'daydapskbvexdbeh')DEEPSEEK_API_KEY = get_env('DEEPSEEK_API_KEY', 'xxxxxxxxxxxxxxxxxxxxxxx')  # 新增DeepSeek API密钥# 检查必要的访问密钥if not ALIYUN_ACCESS_KEY or not ALIYUN_ACCESS_SECRET:    logger.error("阿里云访问密钥未设置！请配置ALIYUN_ACCESS_KEY和ALIYUN_ACCESS_SECRET环境变量")    exit(1)# 初始化客户端try:    logger.info(f"初始化OTS客户端: 端点={OTS_ENDPOINT}, 实例={OTS_INSTANCE_NAME}")    ots_client = OTSClient(        OTS_ENDPOINT,        ALIYUN_ACCESS_KEY,        ALIYUN_ACCESS_SECRET,        OTS_INSTANCE_NAME,        logger_name='ots',        log_level=logging.INFO    )    logger.info(f"初始化OSS客户端: 存储桶={OSS_BUCKET_NAME}, 端点={OSS_ENDPOINT}")    oss_auth = oss2.Auth(ALIYUN_ACCESS_KEY, ALIYUN_ACCESS_SECRET)    oss_bucket = oss2.Bucket(oss_auth, OSS_ENDPOINT, OSS_BUCKET_NAME)    logger.info("OTS和OSS客户端初始化成功")except Exception as e:    logger.error(f"客户端初始化失败: {str(e)}", exc_info=True)    exit(1)# 创建Flask应用 - 将app定义移到前面app = Flask(__name__)# 全局CORS处理@app.after_requestdef add_cors_headers(response):    response.headers['Access-Control-Allow-Origin'] = '*'    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'    return response# 创建必要的表格def create_tables():    try:        # 创建图书表        if OTS_TABLE_NAME not in ots_client.list_table():            logger.info("创建图书表...")            table_meta = TableMeta(OTS_TABLE_NAME, [('book_id', 'STRING')])            table_options = TableOptions()            reserved_throughput = ReservedThroughput(CapacityUnit(0, 0))            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"图书表 {OTS_TABLE_NAME} 创建成功")        # 创建用户表        if USERS_TABLE not in ots_client.list_table():            logger.info("创建用户表...")            table_meta = TableMeta(USERS_TABLE, [('email', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"用户表 {USERS_TABLE} 创建成功")        # 创建验证码表        if VERIFICATION_CODES_TABLE not in ots_client.list_table():            logger.info("创建验证码表...")            table_meta = TableMeta(VERIFICATION_CODES_TABLE, [('email', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"验证码表 {VERIFICATION_CODES_TABLE} 创建成功")        # 创建借阅记录表        if BORROW_RECORDS_TABLE not in ots_client.list_table():            logger.info("创建借阅记录表...")            table_meta = TableMeta(BORROW_RECORDS_TABLE, [('borrow_id', 'STRING')])            ots_client.create_table(table_meta, table_options, reserved_throughput)            logger.info(f"借阅记录表 {BORROW_RECORDS_TABLE} 创建成功")    except Exception as e:        logger.error(f"创建表格失败: {str(e)}", exc_info=True)# 初始化时创建表格create_tables()# 密码哈希函数def hash_password(password):    return hashlib.sha256(password.encode('utf-8')).hexdigest()# 发送验证码def send_verification_code(email):    code = str(random.randint(100000, 999999))    logger.info(f"为 {email} 生成验证码: {code}")    expire_time = int(time.time()) + 300    try:        primary_key = [('email', email)]        attribute_columns = [('code', code), ('expire_time', expire_time)]        row = Row(primary_key, attribute_columns)        # 使用原始条件字符串        ots_client.put_row(VERIFICATION_CODES_TABLE, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"验证码存储成功: {email}")    except Exception as e:        logger.error(f"存储验证码失败: {str(e)}", exc_info=True)        return False    try:        message = MIMEText(f"欢迎来到FluxLib泛集库，您的验证码是: {code}，5分钟内有效。")        message['Subject'] = 'FluxLib泛集库注册验证码'        message['From'] = EMAIL_USER        message['To'] = email        with smtplib.SMTP_SSL(EMAIL_HOST, EMAIL_PORT) as server:            server.login(EMAIL_USER, EMAIL_PASSWORD)            server.sendmail(EMAIL_USER, [email], message.as_string())            logger.info(f"验证码邮件发送成功: {email}")        return True    except Exception as e:        logger.error(f"发送邮件失败: {str(e)}", exc_info=True)        return False# 验证验证码def verify_code(email, code):    try:        primary_key = [('email', email)]        consumed, return_row, next_token = ots_client.get_row(            VERIFICATION_CODES_TABLE,            primary_key,            columns_to_get=['code', 'expire_time']        )        if return_row is None:            logger.warning(f"验证码记录不存在: {email}")            return False        stored_code = None        expire_time = 0        for col_name, col_value, col_timestamp in return_row.attribute_columns:            if col_name == 'code':                stored_code = col_value            elif col_name == 'expire_time':                expire_time = col_value        current_time = int(time.time())        if stored_code == code and expire_time > current_time:            logger.info(f"验证码验证成功: {email}")            return True        logger.warning(f"验证码无效或已过期: {email}")        return False    except Exception as e:        logger.error(f"验证验证码失败: {str(e)}", exc_info=True)        return False# 获取用户信息def get_user(email):    try:        primary_key = [('email', email)]        consumed, return_row, next_token = ots_client.get_row(USERS_TABLE, primary_key)        if return_row is None:            logger.info(f"用户不存在: {email}")            return None        user = {'email': email}        for col_name, col_value, col_timestamp in return_row.attribute_columns:            user[col_name] = col_value        logger.info(f"获取用户成功: {email}")        return user    except Exception as e:        logger.error(f"获取用户失败: {str(e)}", exc_info=True)        return None# 注册用户def register_user(email, password, code):    if not verify_code(email, code):        return False, "验证码错误或已过期"    if get_user(email):        return False, "该邮箱已注册"    user_id = str(uuid.uuid4())    hashed_pw = hash_password(password)    created_at = int(time.time())    try:        primary_key = [('email', email)]        attribute_columns = [            ('user_id', user_id),            ('password', hashed_pw),            ('created_at', created_at),            ('role', 'user'),            ('is_verified', 'true')        ]        row = Row(primary_key, attribute_columns)        # 使用原始条件字符串        ots_client.put_row(USERS_TABLE, row, Condition(RowExistenceExpectation.EXPECT_NOT_EXIST))        logger.info(f"用户注册成功: {email}")        return True, user_id    except Exception as e:        logger.error(f"注册用户失败: {str(e)}", exc_info=True)        return False, str(e)# 用户登录def login_user(email, password):    user = get_user(email)    if not user:        return False, "用户不存在"    hashed_pw = hash_password(password)    if user['password'] == hashed_pw:        logger.info(f"用户登录成功: {email}")        return True, {            'user_id': user['user_id'],            'email': email,            'role': user.get('role', 'user')        }    logger.warning(f"密码错误: {email}")    return False, "密码错误"# 创建管理员账户def create_admin_user():    admin_email = "admin@bookmgmt.com"    admin_password = "Admin@1234"    if not get_user(admin_email):        user_id = str(uuid.uuid4())        hashed_pw = hash_password(admin_password)        created_at = int(time.time())        try:            primary_key = [('email', admin_email)]            attribute_columns = [                ('user_id', user_id),                ('password', hashed_pw),                ('created_at', created_at),                ('role', 'admin'),                ('is_verified', 'true')            ]            row = Row(primary_key, attribute_columns)            # 使用原始条件字符串            ots_client.put_row(USERS_TABLE, row, Condition(RowExistenceExpectation.IGNORE))            logger.info(f"管理员账户已创建: {admin_email}")        except Exception as e:            logger.error(f"创建管理员失败: {str(e)}", exc_info=True)# 获取图书总数def get_total_books(category=None):    try:        count = 0        start_primary_key = [('book_id', INF_MIN)]        end_primary_key = [('book_id', INF_MAX)]        condition = None        if category:            condition = SingleColumnCondition(                'category',                category,                ComparatorType.EQUAL            )        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                OTS_TABLE_NAME,                'FORWARD',                next_start_primary_key,                end_primary_key,                limit=1000,                max_version=1,                column_filter=condition            )            count += len(row_list)        return count    except Exception as e:        logger.error(f"获取图书总数失败: {str(e)}", exc_info=True)        return 0# 获取图书列表def get_books(page=1, size=10):    try:        category = request.args.get('category', '')        offset = (page - 1) * size        start_primary_key = [('book_id', INF_MIN)]        end_primary_key = [('book_id', INF_MAX)]        condition = None        if category:            condition = SingleColumnCondition(                'category',                category,                ComparatorType.EQUAL            )        consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(            OTS_TABLE_NAME,            'FORWARD',            start_primary_key,            end_primary_key,            limit=size,            max_version=1,            column_filter=condition        )        books = []        for row in row_list:            book = {}            for pk in row.primary_key:                book[pk[0]] = pk[1]            for col in row.attribute_columns:                book[col[0]] = col[1]            # 确保所有字段存在            books.append({                'book_id': book.get('book_id', ''),                'title': book.get('title', ''),                'cover': book.get('cover', ''),                'category': book.get('category', ''),                'status': book.get('status', 'available'),                'stock': int(book.get('stock', 0)),                'author': book.get('author', ''),                'publisher': book.get('publisher', ''),                'price': float(book.get('price', 0.0))            })        total = get_total_books(category)        return {            'statusCode': 200,            'headers': {'Content-Type': 'application/json'},            'body': json.dumps({                'items': books,                'total': total,                'page': page,                'size': size            })        }    except Exception as e:        logger.error(f"获取图书列表失败: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'headers': {'Content-Type': 'application/json'},            'body': json.dumps({'error': 'Failed to get books'})        }# 创建图书def create_book(book_data):    try:        if not book_data.get('title'):            return {                'statusCode': 400,                'body': json.dumps({'error': '书名是必填项'})            }        book = {            'book_id': str(uuid.uuid4()),            'created_at': int(time.time()),            'updated_at': int(time.time()),            'status': book_data.get('status', 'available'),            'stock': int(book_data.get('stock', 0))        }        fields = ['title', 'author', 'publisher', 'isbn', 'price', 'category', 'description', 'cover']        for field in fields:            if field in book_data:                book[field] = book_data[field]        if 'price' in book:            try:                book['price'] = float(book['price'])            except:                book['price'] = 0.0        primary_key = [('book_id', book['book_id'])]        attribute_columns = []        for key, value in book.items():            if key != 'book_id':                attribute_columns.append((key, value))        row = Row(primary_key, attribute_columns)        # 使用原始条件字符串        ots_client.put_row(OTS_TABLE_NAME, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"创建图书成功: {book['book_id']}")        return {            'statusCode': 201,            'headers': {'Content-Type': 'application/json'},            'body': json.dumps({                'book_id': book['book_id'],                'message': '图书创建成功'            })        }    except Exception as e:        logger.error(f"创建图书失败: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'headers': {'Content-Type': 'application/json'},            'body': json.dumps({                'error': '创建图书失败',                'detail': str(e)            })        }# 获取图书详情def get_book(book_id):    try:        primary_key = [('book_id', book_id)]        consumed, return_row, next_token = ots_client.get_row(OTS_TABLE_NAME, primary_key)        if return_row is None:            return {                'statusCode': 404,                'body': json.dumps({'error': 'Book not found'})            }        book = {}        for pk in return_row.primary_key:            book[pk[0]] = pk[1]        for col in return_row.attribute_columns:            book[col[0]] = col[1]        # 确保数字字段类型正确        book['stock'] = int(book.get('stock', 0))        book['price'] = float(book.get('price', 0.0))        # 获取借阅历史        book['borrow_history'] = get_borrow_history(book_id)        return {            'statusCode': 200,            'body': json.dumps(book)        }    except Exception as e:        logger.error(f"获取图书失败: {book_id} - {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': 'Failed to get book'})        }# 获取借阅历史def get_borrow_history(book_id):    try:        # 直接使用全表扫描，不使用条件过滤        history = []        start_primary_key = [('borrow_id', INF_MIN)]        end_primary_key = [('borrow_id', INF_MAX)]        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                BORROW_RECORDS_TABLE,                'FORWARD',                next_start_primary_key,                end_primary_key,                limit=100,                max_version=1            )            for row in row_list:                record = {}                for pk in row.primary_key:                    record[pk[0]] = pk[1]                for col in row.attribute_columns:                    record[col[0]] = col[1]                # 在内存中过滤                if record.get('book_id') == book_id:                    # 确保日期字段为整数                    if 'borrow_date' in record:                        record['borrow_date'] = int(record['borrow_date'])                    if 'due_date' in record:                        record['due_date'] = int(record['due_date'])                    history.append(record)        return history    except Exception as e:        logger.error(f"获取借阅历史失败: {book_id} - {str(e)}", exc_info=True)        return []# 获取借阅历史def get_borrow_history(book_id):    try:        # 直接使用全表扫描，不使用条件过滤        history = []        start_primary_key = [('borrow_id', INF_MIN)]        end_primary_key = [('borrow_id', INF_MAX)]        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                BORROW_RECORDS_TABLE,                'FORWARD',                next_start_primary_key,                end_primary_key,                limit=100,                max_version=1            )            for row in row_list:                record = {}                for pk in row.primary_key:                    record[pk[0]] = pk[1]                for col in row.attribute_columns:                    record[col[0]] = col[1]                # 在内存中过滤                if record.get('book_id') == book_id:                    # 确保日期字段为整数                    if 'borrow_date' in record:                        record['borrow_date'] = int(record['borrow_date'])                    if 'due_date' in record:                        record['due_date'] = int(record['due_date'])                    history.append(record)        return history    except Exception as e:        logger.error(f"获取借阅历史失败: {book_id} - {str(e)}", exc_info=True)        return []# 更新图书def update_book(book_id, book_data):    try:        if not book_data:            return {                'statusCode': 400,                'body': json.dumps({'error': 'Invalid request body'})            }        book_data['updated_at'] = int(time.time())        primary_key = [('book_id', book_id)]        update_of_attribute_columns = {'PUT': []}        for key, value in book_data.items():            if key != 'book_id':                update_of_attribute_columns['PUT'].append((key, value))        # 创建Row对象        row = Row(primary_key, update_of_attribute_columns)        # 使用原始条件字符串        ots_client.update_row(OTS_TABLE_NAME, row, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"更新图书成功: {book_id}")        return {            'statusCode': 200,            'body': json.dumps({'message': 'Book updated successfully'})        }    except Exception as e:        logger.error(f"更新图书失败: {book_id} - {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': 'Failed to update book'})        }# 删除图书def delete_book(book_id):    try:        primary_key = [('book_id', book_id)]        # 使用原始条件字符串        ots_client.delete_row(OTS_TABLE_NAME, primary_key, Condition(RowExistenceExpectation.IGNORE))        logger.info(f"删除图书成功: {book_id}")        return {            'statusCode': 200,            'body': json.dumps({'message': 'Book deleted successfully'})        }    except Exception as e:        logger.error(f"删除图书失败: {book_id} - {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': 'Failed to delete book'})        }# 生成预签名URLdef generate_presigned_url(file_name, file_type):    try:        if not file_name or not file_type:            return {                'statusCode': 400,                'body': json.dumps({'error': 'Missing file_name or file_type'})            }        unique_name = f"{uuid.uuid4()}-{file_name}"        object_path = f"book-covers/{unique_name}"        headers = {'Content-Type': file_type}        url = oss_bucket.sign_url('PUT', object_path, 3600, headers=headers)        endpoint = OSS_ENDPOINT.replace('https://', '').replace('http://', '')        access_url = f"https://{OSS_BUCKET_NAME}.{endpoint}/{object_path}"        return {            'statusCode': 200,            'body': json.dumps({                'presigned_url': url,                'access_url': access_url            })        }    except Exception as e:        logger.error(f"生成预签名URL失败: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({                'error': '生成预签名URL失败',                'detail': str(e)            })        }# 获取当前用户ID - 添加详细日志def get_current_user_id(headers):    auth_header = headers.get('Authorization', '')    logger.info(f"Authorization header: '{auth_header}'")    if auth_header.startswith('Bearer '):        token = auth_header[7:]        logger.info(f"Extracted token: {token}")        return token    logger.warning("Authorization header missing or invalid format")    return None# 获取用户的借阅记录def get_borrowing_record(book_id, user_id):    try:        # 查询借阅记录        start_primary_key = [('borrow_id', INF_MIN)]        end_primary_key = [('borrow_id', INF_MAX)]        # 创建复合条件：图书ID + 用户ID + 状态为borrowed        composite_condition = CompositeColumnCondition(LogicalOperator.AND)        composite_condition.add_sub_condition(            SingleColumnCondition('book_id', book_id, ComparatorType.EQUAL)        )        composite_condition.add_sub_condition(            SingleColumnCondition('user_id', user_id, ComparatorType.EQUAL)        )        composite_condition.add_sub_condition(            SingleColumnCondition('status', 'borrowed', ComparatorType.EQUAL)        )        consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(            BORROW_RECORDS_TABLE,            'FORWARD',            next_start_primary_key,            end_primary_key,            max_version=1,            column_filter=composite_condition,            limit=1  # 只获取一条记录        )        if not row_list:            return None        # 提取借阅记录        record = {}        row = row_list[0]        for pk in row.primary_key:            record[pk[0]] = pk[1]        for col in row.attribute_columns:            record[col[0]] = col[1]        return record    except Exception as e:        logger.error(f"获取借阅记录失败: {str(e)}", exc_info=True)        return None# 借阅图书 - 使用get_row + put_row代替update_rowdef borrow_book(book_id, headers, days=30):    try:        logger.info(f"开始借阅图书: book_id={book_id}, days={days}")        user_id = get_current_user_id(headers)        if not user_id:            logger.warning("未授权访问，无法获取用户ID")            return {                'statusCode': 401,                'body': json.dumps({'error': '未授权访问'})            }        logger.info(f"用户已授权: user_id={user_id}")        # 获取图书信息检查库存        book_response = get_book(book_id)        logger.info(f"获取图书详情响应: statusCode={book_response['statusCode']}")        # 检查图书详情响应状态        if book_response['statusCode'] != 200:            logger.warning(f"获取图书详情失败: statusCode={book_response['statusCode']}")            return book_response        try:            book_info = json.loads(book_response['body'])        except Exception as e:            logger.error(f"解析图书信息失败: {str(e)}")            return {                'statusCode': 500,                'body': json.dumps({'error': '解析图书信息失败'})            }        # 确保库存字段存在且为整数        stock = book_info.get('stock', 0)        try:            stock = int(stock)        except:            stock = 0        logger.info(f"借阅前库存检查: book_id={book_id}, stock={stock}")        if stock <= 0:            logger.warning(f"库存不足，无法借阅: book_id={book_id}, stock={stock}")            return {                'statusCode': 400,                'body': json.dumps({'error': '图书库存不足'})            }        # 使用get_row获取完整图书数据        try:            # 获取图书当前所有属性            primary_key = [('book_id', book_id)]            consumed, return_row, next_token = ots_client.get_row(OTS_TABLE_NAME, primary_key)            if not return_row:                return {                    'statusCode': 404,                    'body': json.dumps({'error': '图书不存在'})                }            # 构建更新后的图书属性（保留所有现有字段）            updated_book = {}            for col_name, col_value, col_timestamp in return_row.attribute_columns:                updated_book[col_name] = col_value            # 只更新库存和更新时间（保留封面等所有其他字段）            updated_book['stock'] = stock - 1            updated_book['updated_at'] = int(time.time())            # 构建属性列            attribute_columns = []            for key, value in updated_book.items():                attribute_columns.append((key, value))            # 使用put_row更新整行数据（保留所有字段）            row = Row(primary_key, attribute_columns)            ots_client.put_row(OTS_TABLE_NAME, row, Condition(RowExistenceExpectation.IGNORE))            logger.info(f"库存更新成功: book_id={book_id}, 新库存={stock - 1}")        except OTSServiceError as e:            logger.error(f"OTS服务错误: {e.message}, code={e.code}")            return {                'statusCode': 500,                'body': json.dumps({'error': '库存更新失败'})            }        except Exception as e:            logger.error(f"更新库存失败: {str(e)}", exc_info=True)            return {                'statusCode': 500,                'body': json.dumps({'error': '库存更新失败'})            }        # 创建借阅记录        borrow_id = str(uuid.uuid4())        borrow_data = {            'borrow_id': borrow_id,            'book_id': book_id,            'user_id': user_id,            'borrow_date': int(time.time()),            'due_date': int(time.time()) + days * 24 * 3600,  # 根据天数计算到期时间            'status': 'borrowed'        }        try:            borrow_primary_key = [('borrow_id', borrow_id)]            borrow_attribute_columns = [                ('book_id', borrow_data['book_id']),                ('user_id', borrow_data['user_id']),                ('borrow_date', borrow_data['borrow_date']),                ('due_date', borrow_data['due_date']),                ('status', borrow_data['status'])            ]            borrow_row = Row(borrow_primary_key, borrow_attribute_columns)            ots_client.put_row(BORROW_RECORDS_TABLE, borrow_row, Condition(RowExistenceExpectation.IGNORE))            logger.info(f"借阅记录创建成功: borrow_id={borrow_id}")        except Exception as e:            logger.error(f"创建借阅记录失败: {str(e)}", exc_info=True)            # 尝试回滚库存（同样保留所有字段）            try:                # 回滚库存                updated_book['stock'] = stock                updated_book['updated_at'] = int(time.time())                # 构建属性列                rollback_attributes = []                for key, value in updated_book.items():                    rollback_attributes.append((key, value))                # 使用put_row回滚库存（保留所有字段）                rollback_row = Row(primary_key, rollback_attributes)                ots_client.put_row(OTS_TABLE_NAME, rollback_row, Condition(RowExistenceExpectation.IGNORE))                logger.info(f"库存回滚成功: book_id={book_id}")            except Exception as e:                logger.error(f"库存回滚失败: {str(e)}", exc_info=True)            return {                'statusCode': 500,                'body': json.dumps({'error': '借阅记录创建失败'})            }        return {            'statusCode': 200,            'body': json.dumps({                'success': True,                'borrow_id': borrow_id,                'due_date': borrow_data['due_date']            })        }    except Exception as e:        logger.error(f"借阅图书失败 [book_id={book_id}, user_id={user_id}]: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '借阅失败'})        }# 归还图书 - 更新库存和借阅记录状态def return_book(book_id, headers):    try:        user_id = get_current_user_id(headers)        if not user_id:            logger.warning("未授权访问，无法获取用户ID")            return {                'statusCode': 401,                'body': json.dumps({'error': '未授权访问'})            }        # 获取图书当前库存        book_response = get_book(book_id)        if book_response['statusCode'] != 200:            return book_response        try:            book_info = json.loads(book_response['body'])            stock = book_info.get('stock', 0)            try:                stock = int(stock)            except:                stock = 0        except:            stock = 0        # 获取用户的借阅记录（状态为borrowed）        borrow_record = get_borrowing_record(book_id, user_id)        if not borrow_record:            logger.warning(f"未找到借阅记录: book_id={book_id}, user_id={user_id}")            return {                'statusCode': 400,                'body': json.dumps({'error': '未找到借阅记录'})            }        borrow_id = borrow_record.get('borrow_id')        if not borrow_id:            logger.warning("借阅记录中未找到borrow_id")            return {                'statusCode': 500,                'body': json.dumps({'error': '借阅记录格式错误'})            }        # 增加库存        primary_key = [('book_id', book_id)]        update_of_attribute_columns = {            'PUT': [                ('stock', stock + 1),                ('updated_at', int(time.time()))            ]        }        # 创建Row对象        row = Row(primary_key, update_of_attribute_columns)        ots_client.update_row(            OTS_TABLE_NAME,            row,            Condition(RowExistenceExpectation.IGNORE)        )        logger.info(f"库存增加成功: book_id={book_id}, 新库存={stock + 1}")        # 更新借阅记录状态为已归还        borrow_primary_key = [('borrow_id', borrow_id)]        update_borrow_columns = {            'PUT': [                ('status', 'returned'),                ('return_date', int(time.time()))            ]        }        # 创建Row对象        row = Row(borrow_primary_key, update_borrow_columns)        ots_client.update_row(            BORROW_RECORDS_TABLE,            row,            Condition(RowExistenceExpectation.IGNORE)        )        logger.info(f"借阅记录更新为已归还: borrow_id={borrow_id}")        return {            'statusCode': 200,            'body': json.dumps({'success': True})        }    except Exception as e:        logger.error(f"归还图书失败 [book_id={book_id}, user_id={user_id}]: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '归还失败'})        }# 批量借阅 - 复用单个借阅逻辑def batch_borrow_books(body, headers):    try:        user_id = get_current_user_id(headers)        if not user_id:            logger.warning("未授权访问，无法获取用户ID")            return {                'statusCode': 401,                'body': json.dumps({'error': '未授权访问'})            }        book_ids = body.get('book_ids', [])        if not book_ids:            return {                'statusCode': 400,                'body': json.dumps({'error': '请选择要借阅的图书'})            }        results = []        success_count = 0        for book_id in book_ids:            try:                # 调用单个借阅函数                borrow_response = borrow_book(book_id, headers)                if borrow_response['statusCode'] == 200:                    borrow_info = json.loads(borrow_response['body'])                    results.append({                        'book_id': book_id,                        'success': True,                        'borrow_id': borrow_info.get('borrow_id', ''),                        'due_date': borrow_info.get('due_date', '')                    })                    success_count += 1                else:                    error_info = json.loads(borrow_response['body'])                    results.append({                        'book_id': book_id,                        'success': False,                        'error': error_info.get('error', '借阅失败')                    })            except Exception as e:                results.append({                    'book_id': book_id,                    'success': False,                    'error': str(e)                })        return {            'statusCode': 200,            'body': json.dumps({                'success': True,                'borrowed_count': success_count,                'results': results            })        }    except Exception as e:        logger.error(f"批量借阅失败 [user_id={user_id}]: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '批量借阅失败'})        }# 获取用户借阅记录def get_user_borrows(headers):    try:        # 获取当前用户ID        user_id = get_current_user_id(headers)        if not user_id:            return {                'statusCode': 401,                'body': json.dumps({'error': 'Unauthorized'})            }        # 查询借阅记录        start_primary_key = [('borrow_id', INF_MIN)]        end_primary_key = [('borrow_id', INF_MAX)]        condition = SingleColumnCondition(            'user_id',            user_id,            ComparatorType.EQUAL        )        borrow_records = []        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                BORROW_RECORDS_TABLE,                'FORWARD',                next_start_primary_key,                end_primary_key,                max_version=1,                column_filter=condition            )            for row in row_list:                record = {}                for pk in row.primary_key:                    record[pk[0]] = pk[1]                for col in row.attribute_columns:                    record[col[0]] = col[1]                borrow_records.append(record)        # 获取图书信息        for record in borrow_records:            book_id = record.get('book_id')            if book_id:                book_response = get_book(book_id)                # 确保正确解析图书信息                if book_response['statusCode'] == 200:                    try:                        book_info = json.loads(book_response['body'])                        record['book_title'] = book_info.get('title', '未知图书')                        record['book_cover'] = book_info.get('cover', '')  # 添加封面信息                    except Exception as e:                        logger.error(f"解析图书信息失败: {str(e)}")                        record['book_title'] = '未知图书'                else:                    record['book_title'] = '未知图书'            else:                record['book_title'] = '未知图书'        return {            'statusCode': 200,            'body': json.dumps({                'items': borrow_records            })        }    except Exception as e:        logger.error(f"获取借阅记录失败: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': 'Failed to get borrow records'})        }# 批量归还图书def batch_return_books(body, headers):    try:        # 获取当前用户ID        user_id = get_current_user_id(headers)        if not user_id:            return {                'statusCode': 401,                'body': json.dumps({'error': 'Unauthorized'})            }        borrow_ids = body.get('borrow_ids', [])        results = []        for borrow_id in borrow_ids:            # 获取借阅记录            primary_key = [('borrow_id', borrow_id)]            consumed, return_row, next_token = ots_client.get_row(BORROW_RECORDS_TABLE, primary_key)            if not return_row:                results.append({'borrow_id': borrow_id, 'success': False, 'error': '记录不存在'})                continue            # 验证用户权限            record_user_id = None            record_book_id = None            record_status = None            for col_name, col_value, col_timestamp in return_row.attribute_columns:                if col_name == 'user_id':                    record_user_id = col_value                elif col_name == 'book_id':                    record_book_id = col_value                elif col_name == 'status':                    record_status = col_value            if record_user_id != user_id:                results.append({'borrow_id': borrow_id, 'success': False, 'error': '无权操作'})                continue            # 检查是否已归还            if record_status != 'borrowed':                results.append({'borrow_id': borrow_id, 'success': False, 'error': '记录已归还'})                continue            # 获取图书ID            if not record_book_id:                results.append({'borrow_id': borrow_id, 'success': False, 'error': '无效的图书ID'})                continue            # 归还图书            return_response = return_book(record_book_id, headers)            if return_response['statusCode'] == 200:                # 更新借阅记录状态                update_of_attribute_columns = {                    'PUT': [                        ('status', 'returned'),                        ('return_date', int(time.time()))                    ]                }                # 创建Row对象                row = Row(primary_key, update_of_attribute_columns)                ots_client.update_row(                    BORROW_RECORDS_TABLE,                    row,                    Condition(RowExistenceExpectation.IGNORE)                )                results.append({'borrow_id': borrow_id, 'success': True})            else:                error_info = json.loads(return_response['body'])                results.append({                    'borrow_id': borrow_id,                    'success': False,                    'error': error_info.get('error', '归还失败')                })        return {            'statusCode': 200,            'body': json.dumps({                'success': True,                'results': results            })        }    except Exception as e:        logger.error(f"批量归还失败: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '批量归还失败'})        }# 通过借阅记录ID归还图书def return_book_by_borrow_id(borrow_id, headers):    try:        # 获取当前用户ID        user_id = get_current_user_id(headers)        if not user_id:            return {                'statusCode': 401,                'body': json.dumps({'error': 'Unauthorized'})            }        # 获取借阅记录        primary_key = [('borrow_id', borrow_id)]        consumed, return_row, next_token = ots_client.get_row(BORROW_RECORDS_TABLE, primary_key)        if not return_row:            return {                'statusCode': 404,                'body': json.dumps({'error': '借阅记录不存在'})            }        # 验证用户权限        record_user_id = None        record_book_id = None        record_status = None        for col_name, col_value, col_timestamp in return_row.attribute_columns:            if col_name == 'user_id':                record_user_id = col_value            elif col_name == 'book_id':                record_book_id = col_value            elif col_name == 'status':                record_status = col_value        if record_user_id != user_id:            return {                'statusCode': 403,                'body': json.dumps({'error': '无权操作此借阅记录'})            }        # 检查是否已归还        if record_status != 'borrowed':            return {                'statusCode': 400,                'body': json.dumps({'error': '借阅记录已归还'})            }        # 获取图书ID        if not record_book_id:            return {                'statusCode': 400,                'body': json.dumps({'error': '无效的图书ID'})            }        # 归还图书        return_response = return_book(record_book_id, headers)        if return_response['statusCode'] == 200:            # 更新借阅记录状态            update_of_attribute_columns = {                'PUT': [                    ('status', 'returned'),                    ('return_date', int(time.time()))                ]            }            # 创建Row对象            row = Row(primary_key, update_of_attribute_columns)            ots_client.update_row(                BORROW_RECORDS_TABLE,                row,                Condition(RowExistenceExpectation.IGNORE)            )            return {                'statusCode': 200,                'body': json.dumps({'success': True})            }        else:            return return_response    except Exception as e:        logger.error(f"通过借阅ID归还图书失败: {str(e)}", exc_info=True)        return {            'statusCode': 500,            'body': json.dumps({'error': '归还失败'})        }# 新增：获取所有图书数据用于AI知识库def get_all_books_for_ai():    """获取所有图书数据用于AI知识库"""    try:        books = []        start_primary_key = [('book_id', INF_MIN)]        end_primary_key = [('book_id', INF_MAX)]        next_start_primary_key = start_primary_key        while next_start_primary_key:            consumed, next_start_primary_key, row_list, next_token = ots_client.get_range(                OTS_TABLE_NAME,                'FORWARD',                next_start_primary_key,                end_primary_key,                limit=100,                max_version=1            )            for row in row_list:                book = {}                for pk in row.primary_key:                    book[pk[0]] = pk[1]                for col in row.attribute_columns:                    book[col[0]] = col[1]                # 只提取AI需要的信息                books.append({                    'title': book.get('title', ''),                    'author': book.get('author', ''),                    'category': book.get('category', ''),                    'description': book.get('description', '')[:200] + '...' if book.get('description') and len(                        book.get('description')) > 200 else book.get('description', ''),                    'status': book.get('status', ''),                    'stock': book.get('stock', 0)                })        return books    except Exception as e:        logger.error(f"获取AI图书数据失败: {str(e)}", exc_info=True)        return []# 新增：使用DeepSeek API处理消息def process_with_deepseek(message, books_data, user_id):    """使用DeepSeek API处理消息"""    # 构建系统提示词    system_prompt = f"""你是一个图书管理AI助手，名为"FluxLib助手"。请根据以下图书信息回答用户问题：可用图书列表:{json.dumps(books_data, ensure_ascii=False, indent=2)}请遵循以下规则:1. 只能推荐上述列表中的图书，不能编造不存在的图书2. 对于图书内容相关问题，基于图书描述信息回答3. 图书馆运营时间: 周一至周五 9:00-21:00, 周末 10:00-18:004. 借阅规则: 每次最多借阅5本，借期30天，可续借一次5. 保持友好、专业的语气6. 如果问题与图书无关，礼貌地表示你专注于图书相关问题7. 回答要简洁明了，突出重点信息当前时间: {time.strftime('%Y-%m-%d %H:%M:%S')}"""    try:        # DeepSeek API调用        url = "https://api.deepseek.com/v1/chat/completions"        headers = {            "Authorization": f"Bearer {DEEPSEEK_API_KEY}",            "Content-Type": "application/json"        }        payload = {            "model": "deepseek-chat",            "messages": [                {"role": "system", "content": system_prompt},                {"role": "user", "content": message}            ],            "temperature": 0.7,            "max_tokens": 2000,            "stream": False        }        response = requests.post(url, headers=headers, json=payload, timeout=30)        response_data = response.json()        if response.status_code == 200:            return response_data['choices'][0]['message']['content']        else:            logger.error(f"DeepSeek API错误: {response_data}")            return "抱歉，我现在遇到了一些技术问题，请稍后再试。"    except requests.exceptions.Timeout:        logger.error("DeepSeek API请求超时")        return "请求超时，请稍后再试。"    except Exception as e:        logger.error(f"DeepSeek调用失败: {str(e)}")        return "处理您的请求时出现了问题，请稍后再试。"# 新增：AI聊天路由@app.route('/ai/chat', methods=['POST'])def handle_ai_chat():    try:        data = request.get_json()        user_message = data.get('message', '')        user_id = get_current_user_id(request.headers)        if not user_id:            return jsonify({'error': '未授权访问'}), 401        if not user_message:            return jsonify({'error': '消息不能为空'}), 400        # 获取图书数据用于构建知识库        books_data = get_all_books_for_ai()        # 调用AI处理函数        response = process_with_deepseek(user_message, books_data, user_id)        return jsonify({            'response': response,            'timestamp': int(time.time())        })    except Exception as e:        logger.error(f"AI聊天处理失败: {str(e)}", exc_info=True)        return jsonify({'error': '处理请求时发生错误'}), 500@app.route("/", methods=["GET"])def index():    return {"message": "Backend is running"}, 200@app.route('/health')def health_check():    return 'OK', 200@app.route('/send-verification-code', methods=['POST'])def handle_send_verification_code():    data = request.get_json()    email = data.get('email')    if not email:        return jsonify({'error': 'Email is required'}), 400    success = send_verification_code(email)    if success:        return jsonify({'message': 'Verification code sent'}), 200    else:        return jsonify({'error': 'Failed to send verification code'}), 500@app.route('/register', methods=['POST'])def handle_register():    data = request.get_json()    email = data.get('email')    password = data.get('password')    code = data.get('code')    if not email or not password or not code:        return jsonify({'error': 'Email, password and code are required'}), 400    success, result = register_user(email, password, code)    if success:        return jsonify({'user_id': result}), 201    else:        return jsonify({'error': result}), 400@app.route('/login', methods=['POST'])def handle_login():    data = request.get_json()    email = data.get('email')    password = data.get('password')    if not email or not password:        return jsonify({'error': 'Email and password are required'}), 400    success, result = login_user(email, password)    if success:        token = str(uuid.uuid4())        return jsonify({            'token': token,            'user_id': result['user_id'],            'email': email,            'role': result['role']        }), 200    else:        return jsonify({'error': result}), 401@app.route('/books', methods=['GET'])def handle_get_books():    page = request.args.get('page', default=1, type=int)    size = request.args.get('size', default=10, type=int)    return get_books(page, size)@app.route('/books', methods=['POST'])def handle_create_book():    data = request.get_json()    return create_book(data)@app.route('/books/<book_id>', methods=['GET'])def handle_get_book(book_id):    return get_book(book_id)@app.route('/books/<book_id>', methods=['PUT'])def handle_update_book(book_id):    data = request.get_json()    return update_book(book_id, data)@app.route('/books/<book_id>', methods=['DELETE'])def handle_delete_book(book_id):    return delete_book(book_id)@app.route('/presigned-url', methods=['GET'])def handle_presigned_url():    file_name = request.args.get('file_name')    file_type = request.args.get('file_type')    return generate_presigned_url(file_name, file_type)@app.route('/books/<book_id>/borrow', methods=['POST'])def handle_borrow_book(book_id):    # 获取借阅期限参数    data = request.get_json()    days = data.get('days', 30)  # 默认为30天    return borrow_book(book_id, request.headers, days)@app.route('/books/<book_id>/return', methods=['POST'])def handle_return_book(book_id):    return return_book(book_id, request.headers)@app.route('/books/batch-borrow', methods=['POST'])def handle_batch_borrow():    try:        data = request.get_json()        if not data:            return jsonify({'error': '请求体为空'}), 400        return batch_borrow_books(data, request.headers)    except Exception as e:        logger.error(f"解析批量借阅请求失败: {str(e)}")        return jsonify({'error': '无效的JSON请求体'}), 400# 获取用户借阅记录@app.route('/user/borrows', methods=['GET'])def handle_get_user_borrows():    return get_user_borrows(request.headers)# 批量归还图书@app.route('/batch-return', methods=['POST'])def handle_batch_return():    try:        data = request.get_json()        if not data:            return jsonify({'error': '请求体为空'}), 400        return batch_return_books(data, request.headers)    except Exception as e:        logger.error(f"解析批量归还请求失败: {str(e)}")        return jsonify({'error': '无效的JSON请求体'}), 400# 通过借阅记录ID归还图书@app.route('/return/<borrow_id>', methods=['POST'])def handle_return_by_borrow_id(borrow_id):    return return_book_by_borrow_id(borrow_id, request.headers)# 主函数if __name__ == "__main__":    create_admin_user()    port = int(os.getenv('FC_SERVER_PORT', '9000'))    app.run(host='0.0.0.0', port=port)